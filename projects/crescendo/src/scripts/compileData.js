const CompileData = JSON.parse("[\"class BehaviourManager {\\r\\n\\tconstructor() {\\r\\n\\t\\t/* list of behaviours */\\r\\n\\t\\tthis.behaviours = [];\\r\\n\\t}\\r\\n\\taddBehaviour(behaviour) {\\r\\n\\t\\tthis.behaviours.push(behaviour);\\r\\n\\t}\\r\\n\\t/* removes behaviour by a given object */\\r\\n\\tremoveBehaviour(gameObject) {\\r\\n\\t\\tfor (let i = 0; i < this.behaviours.length; i++) {\\r\\n\\t\\t\\tif (this.behaviours[i].parent === gameObject) {\\r\\n\\t\\t\\t\\tthis.behaviours.splice(i, 1);\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* broadcasts an event to all behaviours within the class */\\r\\n\\tbroadcastEvent(eventName) {\\r\\n\\t\\t/* loop over all behaviours */\\r\\n\\t\\tfor (let i = 0; i < this.behaviours.length; i++) {\\r\\n\\t\\t\\tthis.behaviours[i].runEvent(eventName);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\",\"class CameraManager {\\r\\n\\tconstructor(sceneBackReference) {\\r\\n\\t\\t/* cameras are stored in hash-map based on their id's, which improves performance and in general makes searching easier */\\r\\n\\t\\tthis.cameras = {};\\r\\n\\t\\t/* the identifier for the active camera, not a reference to the active camera itself */\\r\\n\\t\\tthis.activeCamera = null;\\r\\n\\t\\t/* cameras can have behaviours too */\\r\\n\\t\\tthis.behaviourManager = new BehaviourManager();\\r\\n\\t\\tthis.sceneBackreference = sceneBackReference;\\r\\n\\t}\\r\\n\\taddExternalComponents(camera) {\\r\\n\\t\\tif (camera.hasComponent(\\\"behaviour-script\\\")) {\\r\\n\\t\\t\\tlet behaviour = camera.getComponent(\\\"behaviour-script\\\").parse(camera);\\r\\n\\t\\t\\tcamera.addComponent(behaviour);\\r\\n\\t\\t\\tthis.behaviourManager.addBehaviour(behaviour);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tremoveExternalComponents(camera) {\\r\\n\\t\\tif (camera.hasComponent(\\\"behaviour-script\\\")) {\\r\\n\\t\\t\\tthis.behaviourManager.removeBehaviour(camera);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tswitchToCamera(id) {\\r\\n\\t\\t/* ensure the camera actually exists before switching */\\r\\n\\t\\tif (this.cameras[id]) {\\r\\n\\t\\t\\tthis.activeCamera = id;\\r\\n\\t\\t\\t/* run the init phase when switched to */\\r\\n\\t\\t\\tthis.behaviourManager.broadcastEvent(\\\"init\\\");\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t/* throw an error otherwise, intended behaviour */\\r\\n\\t\\t\\tconsole.error(`camera with the ID \\\"${id}\\\" does not exist`);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* camera id's must be unique, otherwise they will be overwritten */\\r\\n\\taddCamera(camera) {\\r\\n\\t\\t/* warn about camera overwrites, it is not critical but it can cause unintended behaviour */\\r\\n\\t\\tif (this.cameras[camera.id]) {\\r\\n\\t\\t\\tconsole.warn(`camera with the ID \\\"${camera.id}\\\" already exists, it will be overwritten`);\\r\\n\\t\\t}\\r\\n\\t\\tcamera.attachedScene = this.sceneBackreference;\\r\\n\\t\\tthis.cameras[camera.id] = camera;\\r\\n\\t\\tthis.addExternalComponents(camera);\\r\\n\\t}\\r\\n\\tremoveCamera(id) {\\r\\n\\t\\tif (this.cameras[id]) {\\r\\n\\t\\t\\tthis.removeExternalComponents(this.cameras[id]);\\r\\n\\t\\t\\tdelete this.cameras[id];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tgetCameraById(id) {\\r\\n\\t\\tif (this.cameras[id]) {\\r\\n\\t\\t\\treturn this.cameras[id];\\r\\n\\t\\t}\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\tgetActiveCamera() {\\r\\n\\t\\treturn this.cameras[this.activeCamera];\\r\\n\\t}\\r\\n\\t/* renames a camera (used in the gui) */\\r\\n\\trenameCamera(currentId, newId) {\\r\\n\\t\\tthis.cameras[currentId].id = newId;\\r\\n\\t\\tthis.cameras[newId] = this.cameras[currentId];\\r\\n\\t\\tdelete this.cameras[currentId];\\r\\n\\t}\\r\\n\\tupdate() {\\r\\n\\t\\tthis.behaviourManager.broadcastEvent(\\\"update\\\");\\r\\n\\t\\tthis.getActiveCamera().update();\\r\\n\\t}\\r\\n}\",\"/* a class containing all crescendo defined components */\\r\\nconst Components = (function() {\\r\\n\\t\\\"use strict\\\";\\r\\n\\tlet currentZIndex = 0;\\r\\n\\t/* the base parent class for components */\\r\\n\\tclass Component {\\r\\n\\t\\tconstructor(name) {\\r\\n\\t\\t\\tthis.name = name;\\r\\n\\t\\t\\tthis.parent = null;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* base class for renderer type components */\\r\\n\\tclass BaseRenderer extends Component {\\r\\n\\t\\t/* default fill and stroke colours */\\r\\n\\t\\tconstructor(id, fillColour = \\\"#cfe2f3\\\", strokeColour = \\\"#171717\\\") {\\r\\n\\t\\t\\tsuper(id);\\r\\n\\t\\t\\tthis.fillColour = fillColour;\\r\\n\\t\\t\\tthis.strokeColour = strokeColour;\\r\\n\\t\\t\\t/* value between [0, 1] */\\r\\n\\t\\t\\tthis.opacity = 1;\\r\\n\\t\\t\\t/*\\tzIndex tells the rendering engine what order the elements are to be rendered in \\r\\n\\t\\t\\t *\\tit uses a variable automatically give each meshRenderer a unique value\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tthis.zIndex = currentZIndex;\\r\\n\\t\\t\\tcurrentZIndex++;\\r\\n\\t\\t}\\r\\n\\t\\t/* set fill to fully transparent */\\r\\n\\t\\tnoFill() {\\r\\n\\t\\t\\tthis.fillColour = \\\"#0000\\\";\\r\\n\\t\\t}\\r\\n\\t\\t/* set fill to fully transparent */\\r\\n\\t\\tnoStroke() {\\r\\n\\t\\t\\tthis.strokeColour = \\\"#0000\\\";\\r\\n\\t\\t}\\r\\n\\t\\t/* parameters are to be given within the range [0, 255] */\\r\\n\\t\\tsetFillRGBA(red, green, blue, alpha) {\\r\\n\\t\\t\\t/* alpha is an optional parameter, it defaults to 255 */\\r\\n\\t\\t\\tif (alpha === undefined) {\\r\\n\\t\\t\\t\\talpha = 255;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* then convert to hexadecimal */\\r\\n\\t\\t\\tlet redHex = red.toString(16);\\r\\n\\t\\t\\tlet greenHex = green.toString(16);\\r\\n\\t\\t\\tlet blueHex = blue.toString(16);\\r\\n\\t\\t\\tlet alphaHex = alpha.toString(16);\\r\\n\\t\\t\\tthis.fillColour = `#${redHex}${greenHex}${blueHex}${alphaHex})`;\\r\\n\\t\\t}\\r\\n\\t\\tsetFillHex(hex) {\\r\\n\\t\\t\\tthis.fillColour = hex;\\r\\n\\t\\t}\\r\\n\\t\\t/* parameters are to be given within the range [0, 255] */\\r\\n\\t\\tsetStrokeRGBA(red, green, blue, alpha) {\\r\\n\\t\\t\\t/* alpha is an optional parameter, it defaults to 255 */\\r\\n\\t\\t\\tif (alpha === undefined) {\\r\\n\\t\\t\\t\\talpha = 255;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* then convert to hexadecimal */\\r\\n\\t\\t\\tlet redHex = red.toString(16);\\r\\n\\t\\t\\tlet greenHex = green.toString(16);\\r\\n\\t\\t\\tlet blueHex = blue.toString(16);\\r\\n\\t\\t\\tlet alphaHex = alpha.toString(16);\\r\\n\\t\\t\\tthis.strokeColour = `#${redHex}${greenHex}${blueHex}${alphaHex})`;\\r\\n\\t\\t}\\r\\n\\t\\tsetStrokeHex(hex) {\\r\\n\\t\\t\\tthis.strokeColour = hex;\\r\\n\\t\\t}\\r\\n\\t\\tgetFillRGBAValues() {\\r\\n\\t\\t\\tlet colour = this.fillColour;\\r\\n\\t\\t\\t/* extract each value from the rgb and convert to decimal */\\r\\n\\t\\t\\tlet red = parseInt(colour.substring(1, 3), 16);\\r\\n\\t\\t\\tlet green = parseInt(colour.substring(3, 5), 16);\\r\\n\\t\\t\\tlet blue = parseInt(colour.substring(5, 7), 16);\\r\\n\\t\\t\\tlet alpha = null;\\r\\n\\t\\t\\t/* hex code without alpha, defaults to 255 */\\r\\n\\t\\t\\tif (colour.length === 7) {\\r\\n\\t\\t\\t\\talpha = 255;\\r\\n\\t\\t\\t} else if (colour.length === 9) {\\r\\n\\t\\t\\t\\talpha = parseInt(colour.substring(7, 9), 16);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t/* throw an warning if an unsupported hex is used */\\r\\n\\t\\t\\t\\tconsole.warn(`Malformed hexadecimal colour: ${colour}`);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* return a colour object that contains the values for the red, green, blue and alpha channels */\\r\\n\\t\\t\\treturn new Utils(red, green, blue, alpha);\\r\\n\\t\\t}\\r\\n\\t\\tgetStrokeRGBAValues() {\\r\\n\\t\\t\\tlet colour = this.strokeColour;\\r\\n\\t\\t\\t/* extract each value from the rgb and convert to decimal */\\r\\n\\t\\t\\tlet red = parseInt(colour.substring(1, 3), 16);\\r\\n\\t\\t\\tlet green = parseInt(colour.substring(3, 5), 16);\\r\\n\\t\\t\\tlet blue = parseInt(colour.substring(5, 7), 16);\\r\\n\\t\\t\\tlet alpha = null;\\r\\n\\t\\t\\t/* hex code without alpha, defaults to 255 */\\r\\n\\t\\t\\tif (colour.length === 7) {\\r\\n\\t\\t\\t\\talpha = 255;\\r\\n\\t\\t\\t} else if (colour.length === 9) {\\r\\n\\t\\t\\t\\talpha = parseInt(colour.substring(7, 9), 16);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t/* throw an warning if an unsupported hex is used */\\r\\n\\t\\t\\t\\tconsole.warn(`Malformed hexadecimal colour: ${colour}`);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* return a colour object that contains the values for the red, green, blue and alpha channels */\\r\\n\\t\\t\\treturn new Utils(red, green, blue, alpha);\\r\\n\\t\\t}\\r\\n\\t\\tsetOpacity(a) {\\r\\n\\t\\t\\tthis.opacity = a;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/*\\t\\r\\n\\t *\\tan extension of the component class, transform defines:\\r\\n\\t *\\twhere the object is rendered (x, y) in pixels\\r\\n\\t *\\tthe rotation of the object (in radians, clockwise and 0 is facing up)\\r\\n\\t *\\tthe scales of the object (x, y) in pixels\\r\\n\\t */\\r\\n\\tclass Transform extends Component {\\r\\n\\t\\t/* default values if not defined */\\r\\n\\t\\tconstructor(x = 0, y = 0, rotation = 0, scaleX = 50, scaleY = 50) {\\r\\n\\t\\t\\tsuper(\\\"transform\\\");\\r\\n\\t\\t\\t/* position of objects, from the center of the object */\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\t\\t\\t/* useful for elements that want to be always kept on screen such as UI */\\r\\n\\t\\t\\tthis.fixedOnScreen = false;\\r\\n\\t\\t\\t/* rotation, positive is clockwise, in radians, 0 is facing up */\\r\\n\\t\\t\\tthis.rotation = rotation;\\r\\n\\t\\t\\t/* scale of objects, used for rendering, typical objects are rendered at -0.5 to 0.5 pixels, making them 1 pixel wide */\\r\\n\\t\\t\\tthis.scaleX = scaleX;\\r\\n\\t\\t\\tthis.scaleY = scaleY;\\r\\n\\t\\t}\\r\\n\\t\\t/* position fixing means the element is independant of the camera transform and will appears relative to the center of the canvas*/\\r\\n\\t\\tfixPosition() {\\r\\n\\t\\t\\tthis.fixedOnScreen = true;\\r\\n\\t\\t}\\r\\n\\t\\tunfixPosition() {\\r\\n\\t\\t\\tthis.fixedOnScreen = false;\\r\\n\\t\\t}\\r\\n\\t\\t/* moves forwards a number of units depending on the direction of the transform*/\\r\\n\\t\\tforward(units) {\\r\\n\\t\\t\\tthis.x += Math.cos(this.rotation) * units;\\r\\n\\t\\t\\tthis.y += Math.sin(this.rotation) * units;\\r\\n\\t\\t}\\r\\n\\t\\tbackward(units) {\\r\\n\\t\\t\\tthis.x -= Math.cos(this.rotation) * units;\\r\\n\\t\\t\\tthis.y -= Math.sin(this.rotation) * units;\\r\\n\\t\\t}\\r\\n\\t\\tup(units) {\\r\\n\\t\\t\\tthis.y -= units;\\r\\n\\t\\t}\\r\\n\\t\\tdown(units) {\\r\\n\\t\\t\\tthis.y += units;\\r\\n\\t\\t}\\r\\n\\t\\tleft(units) {\\r\\n\\t\\t\\tthis.x -= units;\\r\\n\\t\\t}\\r\\n\\t\\tright(units) {\\r\\n\\t\\t\\tthis.x += units;\\r\\n\\t\\t}\\r\\n\\t\\tsetPosition(x, y) {\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\t\\t}\\r\\n\\t\\tsetScale(x, y) {\\r\\n\\t\\t\\tthis.scaleX = x;\\r\\n\\t\\t\\tthis.scaleY = y;\\r\\n\\t\\t}\\r\\n\\t\\tsetRotation(radians) {\\r\\n\\t\\t\\tthis.rotation = radians;\\r\\n\\t\\t}\\r\\n\\t\\t/* for users who do not know radians, a method is provided in order convert the degrees given to radians and vice versa */\\r\\n\\t\\tsetRotationDegrees(degrees) {\\r\\n\\t\\t\\tthis.rotation = degrees * (180 / Math.PI);\\r\\n\\t\\t}\\r\\n\\t\\tgetRotationDegrees() {\\r\\n\\t\\t\\treturn this.rotation * (Math.PI / 180);\\r\\n\\t\\t}\\r\\n\\t\\t/* points towards a position */\\r\\n\\t\\tpointTowards(x, y) {\\r\\n\\t\\t\\tthis.rotation = Utils.direction(this.x, this.y, x, y);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* the mesh renderer defines how the object is rendered */\\r\\n\\tclass MeshRenderer extends BaseRenderer {\\r\\n\\t\\t/* default values if not defined */\\r\\n\\t\\tconstructor(shape = \\\"circle\\\", fillColour, strokeColour) {\\r\\n\\t\\t\\tsuper(\\\"renderer\\\", fillColour, strokeColour);\\r\\n\\t\\t\\tthis.type = \\\"mesh\\\";\\r\\n\\t\\t\\t/* default mesh renderer is a circle, it can be either circle or rectangle */\\r\\n\\t\\t\\tthis.shape = shape;\\r\\n\\t\\t\\tthis.texture = null;\\r\\n\\t\\t\\tthis.texturePath = null;\\r\\n\\t\\t\\t/* customisable data values used to stretch or shrink overfitting or underfitting textures */\\r\\n\\t\\t\\tthis.textureScaleX = 1;\\r\\n\\t\\t\\tthis.textureScaleY = 1;\\r\\n\\t\\t\\t/* width of the object stroke in pixels */\\r\\n\\t\\t\\tthis.strokeWidth = 1;\\r\\n\\t\\t}\\r\\n\\t\\tsetTextureScale(x, y) {\\r\\n\\t\\t\\tthis.textureScaleX = x;\\r\\n\\t\\t\\tthis.textureScaleY = y;\\r\\n\\t\\t}\\r\\n\\t\\tsetTexture(imagePath) {\\r\\n\\t\\t\\tthis.texturePath = imagePath;\\r\\n\\t\\t\\tthis.texture = FileManager.getImage(imagePath);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* the text renderer defines how the text is rendered */\\r\\n\\tclass TextRenderer extends BaseRenderer {\\r\\n\\t\\tconstructor(text = \\\"Sample Text\\\", fillColour, strokeColour) {\\r\\n\\t\\t\\tsuper(\\\"renderer\\\", fillColour, strokeColour);\\r\\n\\t\\t\\tthis.type = \\\"text\\\";\\r\\n\\t\\t\\t/* default text, serves as a reminder to the user to change it */\\r\\n\\t\\t\\tthis.text = text;\\r\\n\\t\\t\\t/* normal or italic */\\r\\n\\t\\t\\tthis.style = \\\"normal\\\";\\r\\n\\t\\t\\t/* either normal or small-caps */\\r\\n\\t\\t\\tthis.variant = \\\"normal\\\";\\r\\n\\t\\t\\t/* can take on values\\r\\n\\t\\t\\t *\\tbetween 100 and 900 in steps of 100\\r\\n\\t\\t\\t *\\r\\n\\t\\t\\t *\\tor words such as\\r\\n\\t\\t\\t *\\r\\n\\t\\t\\t *\\tlighter\\r\\n\\t\\t\\t *\\tnormal\\r\\n\\t\\t\\t *\\tbold\\r\\n\\t\\t\\t *\\tbolder\\r\\n\\t\\t\\t *\\r\\n\\t\\t\\t * words are only avaliable in the gui\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tthis.weight = \\\"normal\\\";\\r\\n\\t\\t\\t/* default font, is also web-safe */\\r\\n\\t\\t\\t/* \\r\\n\\t\\t\\t *\\tlist of websafe fonts\\r\\n\\t\\t\\t *\\tArial (sans-serif)\\r\\n\\t\\t\\t *\\tVerdana (sans-serif)\\r\\n\\t\\t\\t *\\tHelvetica (sans-serif)\\r\\n\\t\\t\\t *\\tTahoma (sans-serif)\\r\\n\\t\\t\\t *\\tTrebuchet MS (sans-serif)\\r\\n\\t\\t\\t *\\tTimes New Roman (serif)\\r\\n\\t\\t\\t *\\tGeorgia (serif)\\r\\n\\t\\t\\t *\\tGaramond (serif)\\r\\n\\t\\t\\t *\\tCourier New (monospace)\\r\\n\\t\\t\\t *\\tBrush Script MT (cursive)\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\t/* \\r\\n\\t\\t\\t *\\tlist of accessible fonts via the GUI\\r\\n\\t\\t\\t *\\tArial (sans-serif)\\r\\n\\t\\t\\t *\\tVerdana (sans-serif)\\r\\n\\t\\t\\t *\\tHelvetica (sans-serif)\\r\\n\\t\\t\\t *\\tTimes New Roman (serif)\\r\\n\\t\\t\\t *\\tCourier New (monospace)\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tthis.font = \\\"Arial\\\";\\r\\n\\t\\t\\t/* height of the font in units (usually pixels as the base unit is 1 unit = 1 pixel) */\\r\\n\\t\\t\\tthis.size = 16;\\r\\n\\t\\t\\t/*\\talignment can take on the values\\r\\n\\t\\t\\t *\\tleft\\r\\n\\t\\t\\t *\\tcenter\\r\\n\\t\\t\\t *\\tright\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tthis.alignment = \\\"left\\\";\\r\\n\\t\\t\\t/* overwrite default fill colour */\\r\\n\\t\\t\\tthis.fillColour = \\\"#171717\\\";\\r\\n\\t\\t}\\r\\n\\t\\tsetProperties(style, variant, weight, size, font, alignment) {\\r\\n\\t\\t\\tthis.style = style;\\r\\n\\t\\t\\tthis.variant = variant;\\r\\n\\t\\t\\tthis.weight = weight;\\r\\n\\t\\t\\tthis.size = size;\\r\\n\\t\\t\\tthis.font = font;\\r\\n\\t\\t\\tthis.alignment = alignment;\\r\\n\\t\\t}\\r\\n\\t\\tsetText(text) {\\r\\n\\t\\t\\tthis.text = text;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tclass LineRenderer extends BaseRenderer {\\r\\n\\t\\tconstructor(fillColour, strokeColour) {\\r\\n\\t\\t\\tsuper(\\\"renderer\\\", fillColour, strokeColour);\\r\\n\\t\\t\\tthis.type = \\\"line\\\";\\r\\n\\t\\t\\tthis.strokeWidth = 1;\\r\\n\\t\\t\\t/* \\r\\n\\t\\t\\t *\\tdefault butt, but choice between\\r\\n\\t\\t\\t *\\t\\\"butt\\\": ends of lines are squared off\\r\\n\\t\\t\\t *\\t\\\"square\\\": like butt, but added half the stroke widthes length\\r\\n\\t\\t\\t *\\t\\\"round\\\": ends of lines are rounded\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tthis.lineCap = \\\"butt\\\";\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t *\\tdefault miter but choice between\\r\\n\\t\\t\\t *\\t\\\"miter\\\": sharp corners\\r\\n\\t\\t\\t *\\t\\\"round\\\": rounded corners\\r\\n\\t\\t\\t *\\t\\\"bevel\\\": square corners\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tthis.lineJoin = \\\"miter\\\";\\r\\n\\t\\t\\tthis.fill = false;\\r\\n\\t\\t}\\r\\n\\t\\tsetProperties(strokeWidth, lineCap, lineJoin, fill) {\\r\\n\\t\\t\\tthis.strokeWidth = strokeWidth;\\r\\n\\t\\t\\tthis.lineCap = lineCap;\\r\\n\\t\\t\\tthis.lineJoin = lineJoin;\\r\\n\\t\\t\\tthis.fill = fill;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* background renderers are only used by scenes */\\r\\n\\tclass BackgroundRenderer extends Component {\\r\\n\\t\\tconstructor() {\\r\\n\\t\\t\\tsuper(\\\"renderer\\\");\\r\\n\\t\\t\\tthis.type = \\\"background\\\";\\r\\n\\t\\t\\t/* default background colour, matches the theme colour background-variant-3 */\\r\\n\\t\\t\\tthis.colour = \\\"#656565\\\";\\r\\n\\t\\t\\tthis.texture = null;\\r\\n\\t\\t\\tthis.textureScaleX = 1;\\r\\n\\t\\t\\tthis.textureScaleY = 1;\\r\\n\\t\\t\\tthis.offsetX = 0;\\r\\n\\t\\t\\tthis.offsetY = 0;\\r\\n\\t\\t\\tthis.tile = false;\\r\\n\\t\\t}\\r\\n\\t\\tsetTextureScale(x, y) {\\r\\n\\t\\t\\tthis.textureScaleX = x;\\r\\n\\t\\t\\tthis.textureScaleY = y;\\r\\n\\t\\t}\\r\\n\\t\\tsetTexture(image) {\\r\\n\\t\\t\\tthis.texture = image;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* \\r\\n\\t *\\trigidbodies are used by the physics engine, compatible with the physics engine \\r\\n\\t *\\tthey are coupled to transforms (rigidbodies affect transforms and transforms affect rigidbodies)\\r\\n\\t */\\r\\n\\tclass BaseRigidbody extends Component {\\r\\n\\t\\tconstructor(velX = 0, velY = 0, accX = 0, accY = 0, density = 1, restitution = 0.7, isColliding = true, isStatic = false) {\\r\\n\\t\\t\\tsuper(\\\"rigidbody\\\");\\r\\n\\t\\t\\tthis.velocityX = velX;\\r\\n\\t\\t\\tthis.velocityY = velY;\\r\\n\\t\\t\\tthis.accelerationX = accX;\\r\\n\\t\\t\\tthis.accelerationY = accY;\\r\\n\\t\\t\\t/* used instead of mass */\\r\\n\\t\\t\\tthis.density = density;\\r\\n\\t\\t\\t/*\\tvalue in the range [0, 1] where\\r\\n\\t\\t\\t *\\t0 is no bounciness (all energy is lost)\\r\\n\\t\\t\\t *\\tand 1 is no energy loss (ball usually bounces forever)\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tthis.restitution = restitution;\\r\\n\\t\\t\\tthis.isColliding = isColliding;\\r\\n\\t\\t\\tthis.isStatic = isStatic;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tclass CircleRigidbody extends BaseRigidbody {\\r\\n\\t\\tconstructor(velX, velY, accX, accY, density, restitution, isColliding, isStatic) {\\r\\n\\t\\t\\tsuper(velX, velY, accX, accY, density, restitution, isColliding, isStatic);\\r\\n\\t\\t\\tthis.type = \\\"circle\\\";\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tclass RectangleRigidbody extends BaseRigidbody {\\r\\n\\t\\tconstructor(velX, velY, accX, accY, density, restitution, isColliding, isStatic) {\\r\\n\\t\\t\\tsuper(velX, velY, accX, accY, density, restitution, isColliding, isStatic);\\r\\n\\t\\t\\tthis.type = \\\"rectangle\\\";\\r\\n\\t\\t\\tthis.surfaceFriction = 0.99;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tclass LineRigidbody extends Component {\\r\\n\\t\\tconstructor() {\\r\\n\\t\\t\\tsuper(\\\"rigidbody\\\");\\r\\n\\t\\t\\tthis.type = \\\"line\\\";\\r\\n\\t\\t\\tthis.surfaceFriction = 0.99;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tclass BehaviourString extends Component {\\r\\n\\t\\tconstructor(string = Templates.behaviourDefault) {\\r\\n\\t\\t\\tsuper(\\\"behaviour-script\\\");\\r\\n\\t\\t\\t/* one can give it a function, however it will stringify it */\\r\\n\\t\\t\\tif (typeof(string) === \\\"function\\\") {\\r\\n\\t\\t\\t\\tstring = string.toString();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.script = string;\\r\\n\\t\\t}\\r\\n\\t\\tparse(parentObject) {\\r\\n\\t\\t\\t/* eval-like which could be unsafe, but is ok since it is just a client side program */\\r\\n\\t\\t\\tlet l = new Function(\\\"return \\\" + this.script);\\r\\n\\t\\t\\t/* calls a function that returns a class and then instantiates said class and returns it */\\r\\n\\t\\t\\treturn new (l())(parentObject);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* like DOM event listeners, behaviours can have multiple functions for the same event */\\r\\n\\tclass Behaviour extends Component {\\r\\n\\t\\tconstructor(gameObject) {\\r\\n\\t\\t\\tsuper(\\\"behaviour\\\");\\r\\n\\t\\t\\tthis.listeners = {};\\r\\n\\t\\t\\tthis.parent = gameObject;\\r\\n\\t\\t}\\r\\n\\t\\taddEvent(eventName, callback) {\\r\\n\\t\\t\\t/* if the event does not exist yet, then initialise with an empty array */\\r\\n\\t\\t\\tif (this.listeners.hasOwnProperty(eventName) === false) {\\r\\n\\t\\t\\t\\tthis.listeners[eventName] = [];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.listeners[eventName].push(callback);\\r\\n\\t\\t}\\r\\n\\t\\tgetEvents(eventName) {\\r\\n\\t\\t\\tif (this.listeners.hasOwnProperty(eventName)) {\\r\\n\\t\\t\\t\\treturn this.listeners[eventName];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* if it doesnt exist, it means the event listener does not exist yet*/\\r\\n\\t\\t\\treturn [];\\r\\n\\t\\t}\\r\\n\\t\\tdeleteListeners(eventName) {\\r\\n\\t\\t\\tthis.listeners[eventName] = [];\\r\\n\\t\\t}\\r\\n\\t\\trunEvent(eventName) {\\r\\n\\t\\t\\t/* first check if the event listener group exists */\\r\\n\\t\\t\\tif (this.listeners.hasOwnProperty(eventName)) {\\r\\n\\t\\t\\t\\t/* loop over all relevant event listeners and run the event */\\r\\n\\t\\t\\t\\tfor (let i = 0; i < this.listeners[eventName].length; i++) {\\r\\n\\t\\t\\t\\t\\t/* use call instead of typical function calls to set this value */\\r\\n\\t\\t\\t\\t\\tthis.listeners[eventName][i].call(this);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tclass Line extends Component {\\r\\n\\t\\tconstructor(points = [new Vector(-50, 0), new Vector(50, 0)], connectEnds = false) {\\r\\n\\t\\t\\tsuper(\\\"line\\\");\\r\\n\\t\\t\\t/* array of Vectors, take note the points are positioned relative to the attached transform*/\\r\\n\\t\\t\\tthis.points = points;\\r\\n\\t\\t\\t/* if true, will consider the line between the beginning and end points for renderering and physics */\\r\\n\\t\\t\\tthis.connectEnds = connectEnds;\\r\\n\\t\\t}\\r\\n\\t\\t/* return the euclidean distance between the beginning and end points of the line */\\r\\n\\t\\ttotalLength() {\\r\\n\\t\\t\\tlet total = 0;\\r\\n\\t\\t\\tfor (let i = 0; i < this.points.length - 1; i++) {\\r\\n\\t\\t\\t\\ttotal += Utils.dist(this.points[i].x, this.points[i].y, this.points[i + 1].x, this.points[i + 1].y);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* if the line is expected to connect ends, then consider it */\\r\\n\\t\\t\\tif (this.connectEnds) {\\r\\n\\t\\t\\t\\ttotal += Utils.dist(this.points[0].x, this.points[0].y, this.points[this.points.length - 1].x, this.points[this.points.length - 1].y);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn total;\\r\\n\\t\\t}\\r\\n\\t\\tgetLastPoint() {\\r\\n\\t\\t\\treturn this.getPoint(this.points.length - 1);\\r\\n\\t\\t}\\r\\n\\t\\tgetPoint(index) {\\r\\n\\t\\t\\treturn this.points[index];\\r\\n\\t\\t}\\r\\n\\t\\taddPoint(point) {\\r\\n\\t\\t\\tif (point instanceof Vector) {\\r\\n\\t\\t\\t\\tthis.points.push(point);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthrow new Error(`UserError: provided point must be of class vector, instead saw ${typeof point}`);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\taddPointAtIndex(point, index) {\\r\\n\\t\\t\\tthis.points.splice(index, 0, point);\\r\\n\\t\\t}\\r\\n\\t\\tremovePoint(index) {\\r\\n\\t\\t\\t/* should error if index is greater than the length of points or negative, that is intentional behaviour */\\r\\n\\t\\t\\tthis.points.splice(index, 1);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* if enough time add audio*/\\r\\n\\t// class AudioListener extends Component {\\r\\n\\t// \\tconstructor() {\\r\\n\\t// \\t\\tsuper(\\\"audio-source\\\");\\r\\n\\t// \\t\\t/* range between 0 and 1 */\\r\\n\\t// \\t\\tthis.masterVolume = 1;\\r\\n\\t// \\t}\\r\\n\\t// }\\r\\n\\t// class AudioSource extends Component {\\r\\n\\t// \\tconstructor(id) {\\r\\n\\t// \\t\\tsuper(\\\"audio-source\\\");\\r\\n\\t// \\t\\tthis.source = null;\\r\\n\\t// \\t\\tthis.sourcePath = null;\\r\\n\\t// \\t\\tthis.id = id;\\r\\n\\t// \\t\\tthis.volume = 1;\\r\\n\\t// \\t\\tthis.loop = false;\\r\\n\\t// \\t\\t/* defines if the sound should be quieter depending on how close it is */\\r\\n\\t// \\t\\tthis.doProximityAudio = false;\\r\\n\\t// \\t\\t/* min distance before sound fading occurs */\\r\\n\\t// \\t\\tthis.proximityMin = 0;\\r\\n\\t// \\t\\t/* max distance before no sound is heard */\\r\\n\\t// \\t\\tthis.proximityMax = 0;\\r\\n\\t// \\t}\\r\\n\\t// \\tsetSource(audioPath) {\\r\\n\\t// \\t\\tthis.sourcePath = path;\\r\\n\\t// \\t\\tthis.source = FileManager.getaAudio(audioPath);\\r\\n\\t// \\t}\\r\\n\\t// \\tplay() {\\r\\n\\t// \\t\\tif (this.source) {\\r\\n\\t// \\t\\t\\tthis.source.play();\\r\\n\\t// \\t\\t} else {\\r\\n\\t// \\t\\t\\tconsole.warn(\\\"No source for audio-source component\\\");\\r\\n\\t// \\t\\t}\\r\\n\\t// \\t}\\r\\n\\t// \\tsetProximity(min, max) {\\r\\n\\t// \\t\\tthis.proximityMin = min;\\r\\n\\t// \\t\\tthis.proximityMax = max;\\r\\n\\t// \\t}\\r\\n\\t// \\tvolumeAtDistance(distance) {\\r\\n\\t// \\t\\tif (this.doProximityAudio) {\\r\\n\\t// \\t\\t\\t/* rolloff is linear, which is not realistic compare to 1/r but thts ok */\\r\\n\\t// \\t\\t\\treturn this.volume * Utils.map(Utils.clampRange(distance, this.proximityMin, this.proximityMax), this.proximityMin, this.proximityMax, 1, 0);\\r\\n\\t// \\t\\t}\\r\\n\\t// \\t\\treturn this.volume;\\r\\n\\t// \\t}\\r\\n\\t// }\\r\\n\\treturn {\\r\\n\\t\\tComponent,\\r\\n\\t\\tBaseRenderer,\\r\\n\\t\\tTransform,\\r\\n\\t\\tMeshRenderer,\\r\\n\\t\\tBackgroundRenderer,\\r\\n\\t\\tTextRenderer,\\r\\n\\t\\tLineRenderer,\\r\\n\\t\\tBaseRigidbody,\\r\\n\\t\\tCircleRigidbody,\\r\\n\\t\\tRectangleRigidbody,\\r\\n\\t\\tLineRigidbody,\\r\\n\\t\\tBehaviourString,\\r\\n\\t\\tBehaviour,\\r\\n\\t\\tLine,\\r\\n\\t\\t// AudioListener,\\r\\n\\t\\t// AudioSource,\\r\\n\\t};\\r\\n})();\",\"class DefaultOptions {\\r\\n\\tconstructor() {\\r\\n\\t\\tthis.physicsGridSize = 50;\\r\\n\\t\\tthis.physicsEngineWidth = 5000;\\r\\n\\t\\tthis.physicsEngineHeight = 5000;\\r\\n\\t\\tthis.globalGravity = 0.196;\\r\\n\\t\\tthis.physicsIterations = 2;\\r\\n\\t\\tthis.physicsErrorCorrection = 0.5;\\r\\n\\t\\tthis.pixelsPerUnit = 1;\\r\\n\\t}\\r\\n}\",\"/* the render class handles the rendering of gameobjects */\\r\\nclass Application {\\r\\n\\tconstructor(canvasId, options = new DefaultOptions()) {\\r\\n\\t\\tthis.renderer = new Renderer(canvasId);\\r\\n\\t\\tthis.renderer.pixelsPerUnit = options.pixelsPerUnit;\\r\\n\\t\\t/* create managers */\\r\\n\\t\\tthis.sceneManager = new SceneManager();\\r\\n\\t\\t/* create inputs */\\r\\n\\t\\tthis.inputs = new Inputs(canvasId, \\\"body\\\");\\r\\n\\t\\t/* create physics */\\r\\n\\t\\tthis.physics = new PotatoPhysicsEngine(options.physicsEngineWidth, options.physicsEngineHeight, options.physicsIterations);\\r\\n\\t\\t/* set physics to the base size */\\r\\n\\t\\tthis.physics.gridSize(options.physicsGridSize);\\r\\n\\t\\tthis.physics.errorCorrectionCoefficient = options.physicsErrorCorrection;\\r\\n\\t\\tthis.physics.globalGravity.y = options.globalGravity;\\r\\n\\r\\n\\t\\tthis.isRunning = false;\\r\\n\\t\\tthis.options = options;\\r\\n\\r\\n\\t\\t/* empty default function */\\r\\n\\t\\tthis.initFunction = function() {};\\r\\n\\r\\n\\t\\t/* debugging stuff */\\r\\n\\t\\tthis.showCPUTimeBreakdown = false;\\r\\n\\t\\tthis.sceneTime = 0;\\r\\n\\t\\tthis.physicsTime = 0;\\r\\n\\t\\tthis.renderTime = 0;\\r\\n\\t}\\r\\n\\tapplyOptions(options) {\\r\\n\\t\\tthis.renderer.pixelsPerUnit = options.pixelsPerUnit;\\r\\n\\t\\tthis.physics.resizeBounds(options.physicsEngineWidth, options.physicsEngineHeight);\\r\\n\\t\\tthis.physics.iterations = options.physicsIterations;\\r\\n\\t\\tthis.physics.gridSize(options.physicsGridSize);\\r\\n\\t\\tthis.physics.errorCorrectionCoefficient = options.physicsErrorCorrection;\\r\\n\\t\\tthis.physics.globalGravity.y = options.globalGravity;\\r\\n\\t}\\r\\n\\tonInit(func) {\\r\\n\\t\\tthis.initFunction = func;\\r\\n\\t}\\r\\n\\tupdate() {\\r\\n\\t\\t/* update the scene run through all gameobject behaviours */\\r\\n\\t\\tif (this.sceneManager.activeScene) {\\r\\n\\t\\t\\tlet activeScene = this.sceneManager.getActiveScene();\\r\\n\\t\\t\\tlet now = window.performance.now();\\r\\n\\t\\t\\tactiveScene.update();\\r\\n\\t\\t\\tthis.sceneTime = window.performance.now() - now;\\r\\n\\t\\t\\t/* step physics */\\r\\n\\t\\t\\tnow = window.performance.now()\\r\\n\\t\\t\\tthis.physics.step(activeScene.objects);\\r\\n\\t\\t\\tthis.physicsTime = window.performance.now() - now;\\r\\n\\t\\t\\t/* run late updates which are after physics*/\\r\\n\\t\\t\\tactiveScene.lateUpdate();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\trenderCPUTimeBreakdown() {\\r\\n\\t\\tthis.renderer.ctx.fillText(`updating scene: ${Math.round((this.sceneTime) * 100) / 100}ms`, 10, 30);\\r\\n\\t\\tthis.renderer.ctx.fillText(`physics engine: ${Math.round((this.renderTime) * 100) / 100}ms`, 10, 50);\\r\\n\\t\\tthis.renderer.ctx.fillText(`rendering scene: ${Math.round((this.renderTime) * 100) / 100}ms`, 10, 70);\\r\\n\\t\\tthis.renderer.ctx.fillText(`total time: ${Math.round((this.sceneTime + this.physicsTime + this.renderTime) * 100) / 100}ms`, 10, 90);\\r\\n\\t}\\r\\n\\tinit() {\\r\\n\\t\\t/* empty managers */\\r\\n\\t\\tthis.sceneManager = new SceneManager();\\r\\n\\t\\t/* destroy previous event listeners */\\r\\n\\t\\tthis.inputs.destroy();\\r\\n\\t\\t/* initialise the inputs module */\\r\\n\\t\\tthis.inputs.init();\\r\\n\\t\\t/* initialise application */\\r\\n\\t\\tthis.initFunction();\\r\\n\\t\\t/* finally initialise the current scene */\\r\\n\\t\\tif (this.sceneManager.activeScene) {\\r\\n\\t\\t\\tthis.sceneManager.initialiseActiveScene();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tdestroy() {\\r\\n\\t\\t/* stop the application */\\r\\n\\t\\tthis.stop();\\r\\n\\t\\t/* destroy previous event listeners */\\r\\n\\t\\tthis.inputs.destroy();\\r\\n\\t}\\r\\n\\trender(cameraOverride) {\\r\\n\\t\\tlet now = window.performance.now();\\r\\n\\t\\tif (this.sceneManager.activeScene) {\\r\\n\\t\\t\\tif (cameraOverride) {\\r\\n\\t\\t\\t\\tthis.renderer.render(this.sceneManager.getActiveScene(), cameraOverride);\\r\\n\\t\\t\\t} else if (this.sceneManager.getActiveScene().cameraManager.activeCamera) {\\r\\n\\t\\t\\t\\tthis.renderer.render(this.sceneManager.getActiveScene(), this.sceneManager.getActiveScene().cameraManager.getActiveCamera());\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tthis.renderTime = window.performance.now() - now;\\r\\n\\t}\\r\\n\\tmainLoop() {\\r\\n\\t\\tif (this.isRunning) {\\r\\n\\t\\t\\tthis.update();\\r\\n\\t\\t\\tthis.render();\\r\\n\\t\\t\\tif (this.showCPUTimeBreakdown) {\\r\\n\\t\\t\\t\\tthis.renderCPUTimeBreakdown();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\trequestAnimationFrame(this.mainLoop.bind(this));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tstart() {\\r\\n\\t\\tthis.isRunning = true;\\r\\n\\t\\tthis.mainLoop();\\r\\n\\t}\\r\\n\\tstop() {\\r\\n\\t\\tthis.isRunning = false;\\r\\n\\t}\\r\\n\\t\\t\\r\\n}\",\"class GameObject {\\r\\n\\tconstructor(id) {\\r\\n\\t\\tthis.attachedScene = null;\\r\\n\\t\\t/* unique identifier for getting and finding */\\r\\n\\t\\tthis.id = id;\\r\\n\\t\\t/* default properties of gameobjects */\\r\\n\\t\\tthis.components = {};\\r\\n\\t\\t/* used to ensure clones have individual id's */\\r\\n\\t\\tthis.clones = 0;\\r\\n\\t}\\r\\n\\tremoveComponent(componentName) {\\r\\n\\t\\tdelete this.components[componentName];\\r\\n\\t}\\r\\n\\taddComponent(component) {\\r\\n\\t\\tthis.components[component.name] = component;\\r\\n\\t\\tcomponent.parent = this;\\r\\n\\t}\\r\\n\\tgetComponent(name) {\\r\\n\\t\\tif (this.components[name]) {\\r\\n\\t\\t\\treturn this.components[name];\\r\\n\\t\\t}\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\thasComponent(name) {\\r\\n\\t\\treturn this.components.hasOwnProperty(name);\\r\\n\\t}\\r\\n\\t/* deep clones and creates a full, new instance of an object */\\r\\n\\tclone() {\\r\\n\\t\\tthis.clones++;\\r\\n\\t\\t/* create the clone and add the id */\\r\\n\\t\\tlet clone = new GameObject(this.id + ` (${this.clones})`);\\r\\n\\t\\t/* loop through all the components and create copies */\\r\\n\\t\\tfor (let component in this.components) {\\r\\n\\t\\t\\tif (this.components.hasOwnProperty(component)) {\\r\\n\\t\\t\\t\\tlet componentClass = this.components[component].constructor.name;\\r\\n\\t\\t\\t\\tlet newComponent = new Components[componentClass]();\\r\\n\\t\\t\\t\\t/* loop through all the properties in each component */\\r\\n\\t\\t\\t\\tfor (let property in this.components[component]) {\\r\\n\\t\\t\\t\\t\\tif (this.components[component].hasOwnProperty(property)) {\\r\\n\\t\\t\\t\\t\\t\\tnewComponent[property] = this.components[component][property];\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tclone.addComponent(newComponent);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn clone;\\r\\n\\t}\\r\\n}\\r\\n/* a camera is technically considered a game object, however, it does not require a mesh renderer */\\r\\nclass Camera extends GameObject {\\r\\n\\t/* rotation in radians, clockwise with 0 being straight upwards */\\r\\n\\tconstructor(id, x = 0, y = 0, rotation = 0) {\\r\\n\\t\\tsuper(id);\\r\\n\\t\\t/* the camera does not have a mesh renderer, as such it uses different components */\\r\\n\\t\\tthis.components = {};\\r\\n\\t\\tthis.followWithRotation = false;\\r\\n\\t\\t/* a reference to a gameobject instructing the camera to follow */\\r\\n\\t\\tthis.objectoFollow = null;\\r\\n\\t\\tthis.followOffsetX = 0;\\r\\n\\t\\tthis.followOffsetY = 0;\\r\\n\\t}\\r\\n\\t/* follow objects set the center of the object to the camera position causing the camera to follow the object */\\r\\n\\tfollowObject(object, offsetX, offsetY) {\\r\\n\\t\\tif (offsetX === undefined) {\\r\\n\\t\\t\\toffsetX = 0;\\r\\n\\t\\t}\\r\\n\\t\\tif (offsetY === undefined) {\\r\\n\\t\\t\\toffsetY = 0;\\r\\n\\t\\t}\\r\\n\\t\\tthis.followWithRotation = false;\\r\\n\\t\\tthis.objectoFollow = object;\\r\\n\\t\\tthis.followOffsetX = offsetX;\\r\\n\\t\\tthis.followOffsetY = offsetY;\\r\\n\\t}\\r\\n\\t/* same as followObject but matches the rotation of the object*/\\r\\n\\tfollowObjectWithRotation(object, offsetX, offsetY) {\\r\\n\\t\\tthis.followWithRotation = true;\\r\\n\\t\\tthis.objectoFollow = object;\\r\\n\\t\\tthis.followOffsetX = offsetX;\\r\\n\\t\\tthis.followOffsetY = offsetY;\\r\\n\\t}\\r\\n\\tstopFollow() {\\r\\n\\t\\t/* reset values when stop following */\\r\\n\\t\\tthis.objectoFollow = null;\\r\\n\\t\\tthis.followWithRotation = false;\\r\\n\\t\\tthis.followOffsetX = 0;\\r\\n\\t\\tthis.followOffsetY = 0;\\r\\n\\t}\\r\\n\\tfollowPosition(x, y) {\\r\\n\\t\\tthis.followOffsetX = x;\\r\\n\\t\\tthis.followOffsetY = y;\\r\\n\\t}\\r\\n\\tupdate() {\\r\\n\\t\\t/* runs if the camera is following an object */\\r\\n\\t\\tif (this.objectoFollow !== null) {\\r\\n\\t\\t\\tlet transform = this.getComponent(\\\"transform\\\");\\r\\n\\t\\t\\tlet followTransform = this.objectoFollow.getComponent(\\\"transform\\\");\\r\\n\\t\\t\\ttransform.x = followTransform.x;\\r\\n\\t\\t\\ttransform.y = followTransform.y;\\r\\n\\t\\t\\tif (this.followWithRotation) {\\r\\n\\t\\t\\t\\ttransform.rotation = -followTransform.rotation;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\",\"class Inputs {\\r\\n\\tconstructor(mouseElementId, keyboardElementId) {\\r\\n\\t\\tthis.mouse = new MouseInputs(mouseElementId);\\r\\n\\t\\tthis.keys = new KeyInputs(keyboardElementId);\\r\\n\\t}\\r\\n\\tinit() {\\r\\n\\t\\tthis.mouse.init();\\r\\n\\t\\tthis.keys.init();\\r\\n\\t}\\r\\n\\t/* \\r\\n\\t *\\talthough not used much as the application will most likely instantiate only 1 input class\\r\\n\\t *\\tit is useful incase as it will destroy past event listeners preventing leaks\\r\\n\\t */\\r\\n\\tdestroy() {\\r\\n\\t\\tthis.mouse.destroy();\\r\\n\\t\\tthis.keys.destroy();\\r\\n\\t}\\r\\n}\",\"class KeyInputs {\\r\\n\\tconstructor(id) {\\r\\n\\t\\t/* the element the keyboard is attached to */\\r\\n\\t\\tthis.element = document.getElementById(id);\\r\\n\\t\\tthis.keys = [];\\r\\n\\t\\tthis.releasedKeys = [];\\r\\n\\t\\t/* maps keys to a hash map so that they can be accessed in O(1) time */\\r\\n\\t\\tthis.keyMap = {};\\r\\n\\t\\t/* IIFE to set keyMap */\\r\\n\\t\\t(() => {\\r\\n\\t\\t\\tlet keyData = [];\\r\\n\\t\\t\\t/* key datas for commonly used characters */\\r\\n\\t\\t\\tkeyData[8] = \\\"backspace\\\";\\r\\n\\t\\t\\tkeyData[9] = \\\"tab\\\";\\r\\n\\t\\t\\tkeyData[13] = \\\"enter\\\";\\r\\n\\t\\t\\tkeyData[16] = \\\"shift\\\";\\r\\n\\t\\t\\tkeyData[17] = \\\"control\\\";\\r\\n\\t\\t\\tkeyData[18] = \\\"alt\\\";\\r\\n\\t\\t\\tkeyData[27] = \\\"escape\\\";\\r\\n\\t\\t\\tkeyData[32] = \\\"space\\\";\\r\\n\\t\\t\\tkeyData[37] = \\\"arrowLeft\\\";\\r\\n\\t\\t\\tkeyData[38] = \\\"arrowUp\\\";\\r\\n\\t\\t\\tkeyData[39] = \\\"arrowRight\\\";\\r\\n\\t\\t\\tkeyData[40] = \\\"arrowDown\\\";\\r\\n\\t\\t\\tkeyData[46] = \\\"delete\\\";\\r\\n\\t\\t\\tconst alphabet = \\\"abcdefghijklmnopqrstuvwxyz\\\";\\r\\n\\t\\t\\t/* keys 0-9 */\\r\\n\\t\\t\\tfor (let i = 48; i < 58; i++) {\\r\\n\\t\\t\\t\\tkeyData[i] = i - 48;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* keys a-z */\\r\\n\\t\\t\\tfor (let i = 65; i < 91; i++) {\\r\\n\\t\\t\\t\\tkeyData[i] = alphabet.substr(i - 65, 1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* numpad keys 0-9 */\\r\\n\\t\\t\\tfor (let i = 96; i < 106; i++) {\\r\\n\\t\\t\\t\\tkeyData[i] = \\\"numpad\\\" + (i - 96);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* fn keys */\\r\\n\\t\\t\\tfor (let i = 113; i < 125; i++) {\\r\\n\\t\\t\\t\\tkeyData[i] = \\\"f\\\" + (i - 112);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tkeyData[186] = \\\";\\\";\\r\\n\\t\\t\\tkeyData[187] = \\\"=\\\";\\r\\n\\t\\t\\tkeyData[188] = \\\",\\\";\\r\\n\\t\\t\\tkeyData[189] = \\\"-\\\";\\r\\n\\t\\t\\tkeyData[190] = \\\".\\\";\\r\\n\\t\\t\\tkeyData[191] = \\\"/\\\";\\r\\n\\t\\t\\tkeyData[219] = \\\"[\\\";\\r\\n\\t\\t\\tkeyData[220] = \\\"\\\\\\\\\\\";\\r\\n\\t\\t\\tkeyData[221] = \\\"]\\\";\\r\\n\\t\\t\\tkeyData[222] = \\\"\\\\'\\\";\\r\\n\\t\\t\\t/* remap keys from array of values to hash map */\\r\\n\\t\\t\\tfor (let i = 0; i < keyData.length; i++) {\\r\\n\\t\\t\\t\\tif (keyData[i]) {\\r\\n\\t\\t\\t\\t\\tthis.keyMap[keyData[i]] = i;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t})();\\r\\n\\t\\tconst that = this;\\r\\n\\t\\tthis.keydown = function(e) {\\r\\n\\t\\t\\tif (that.keys[e.keyCode] === true) {\\r\\n\\t\\t\\t\\tthat.releasedKeys[e.keyCode] = false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthat.keys[e.keyCode] = true;\\r\\n\\t\\t};\\r\\n\\t\\tthis.keyup = function(e) {\\r\\n\\t\\t\\tthat.releasedKeys[e.keyCode] = true;\\r\\n\\t\\t\\tthat.keys[e.keyCode] = false;\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\tgetKeyDown(keyName) {\\r\\n\\t\\treturn this.keys[this.keyMap[keyName]];\\r\\n\\t}\\r\\n\\temulateKeyDown(keyName) {\\r\\n\\t\\tthis.keys[this.keyMap[keyName]] = true;\\r\\n\\t}\\r\\n\\temulateKeyUp(keyName) {\\r\\n\\t\\tthis.keys[this.keyMap[keyName]] = false;\\r\\n\\t}\\r\\n\\tinit() {\\r\\n\\t\\tthis.element.addEventListener(\\\"keydown\\\", this.keydown);\\r\\n\\t\\tthis.element.addEventListener(\\\"keyup\\\", this.keyup);\\r\\n\\t}\\r\\n\\t/* \\r\\n\\t *\\talthough not used much as the application will most likely instantiate only 1 input class\\r\\n\\t *\\tit is useful incase as it will destroy past event listeners preventing leaks\\r\\n\\t */\\r\\n\\tdestroy() {\\r\\n\\t\\tthis.element.removeEventListener(\\\"keydown\\\", this.keydown);\\r\\n\\t\\tthis.element.removeEventListener(\\\"keyup\\\", this.keyup);\\r\\n\\t}\\r\\n}\",\"class MouseInputs {\\r\\n\\tconstructor(id) {\\r\\n\\t\\t/* the element the mouse is attached to */\\r\\n\\t\\tthis.element = document.getElementById(id);\\r\\n\\t\\tthis.position = new Vector(0, 0);\\r\\n\\t\\tthis.isLeftButtonDown = false;\\r\\n\\t\\tthis.allowRightClick = true;\\r\\n\\r\\n\\t\\t/* outer referencing */\\r\\n\\t\\tlet that = this;\\r\\n\\t\\tthis.mousemove = function(event) {\\r\\n\\t\\t\\t/* center the mouse position relative to center of screen */\\r\\n\\t\\t\\tlet computedStyle = window.getComputedStyle(that.element);\\r\\n\\t\\t\\tthat.position = new Vector(event.offsetX - Math.round(parseInt(computedStyle.getPropertyValue(\\\"width\\\")) / 2), event.offsetY - Math.round(parseInt(computedStyle.getPropertyValue(\\\"height\\\")) / 2));\\r\\n\\t\\t};\\r\\n\\t\\tthis.mousedown = function(event) {\\r\\n\\t\\t\\tthat.isLeftButtonDown = true;\\r\\n\\t\\t};\\r\\n\\t\\tthis.mouseup = function(event) {\\r\\n\\t\\t\\tthat.isLeftButtonDown = false;\\r\\n\\t\\t};\\r\\n\\t\\tthis.contextmenu = function(event) {\\r\\n\\t\\t\\tif (that.allowRightClick === false) {\\r\\n\\t\\t\\t\\tevent.preventDefault();\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\temulateClick() {\\r\\n\\t\\tthis.isLeftButtonDown = true;\\r\\n\\t}\\r\\n\\temulateUnClick() {\\r\\n\\t\\tthis.isLeftButtonDown = false;\\r\\n\\t}\\r\\n\\tinit() {\\r\\n\\t\\tthis.element.addEventListener(\\\"mousemove\\\", this.mousemove);\\r\\n\\t\\tthis.element.addEventListener(\\\"mousedown\\\", this.mousedown);\\r\\n\\t\\tthis.element.addEventListener(\\\"mouseup\\\", this.mouseup);\\r\\n\\t\\tthis.element.addEventListener(\\\"contextmenu\\\", this.contextmenu);\\r\\n\\t}\\r\\n\\t/* \\r\\n\\t *\\talthough not used much as the application will most likely instantiate only 1 input class\\r\\n\\t *\\tit is useful incase as it will destroy past event listeners preventing leaks\\r\\n\\t */\\r\\n\\tdestroy() {\\r\\n\\t\\tthis.element.removeEventListener(\\\"mousemove\\\", this.mousemove);\\r\\n\\t\\tthis.element.removeEventListener(\\\"mousedown\\\", this.mousedown);\\r\\n\\t\\tthis.element.removeEventListener(\\\"mouseup\\\", this.mouseup);\\r\\n\\t\\tthis.element.removeEventListener(\\\"contextmenu\\\", this.contextmenu);\\t\\r\\n\\t}\\r\\n}\",\"/* physics instance is class allowing for modular use */\\r\\nclass PotatoPhysicsEngine {\\r\\n\\tconstructor(width = 5000, height = 5000, iterations = 2, gridCellsX = 16, gridCellsY = 9) {\\r\\n\\t\\t/* maximal bounds of the physics engine */\\r\\n\\t\\tthis.width = width;\\r\\n\\t\\tthis.height = height;\\r\\n\\t\\tthis.xOffset = width / 2;\\r\\n\\t\\tthis.yOffset = height / 2;\\r\\n\\t\\t/* more iterations means more accurate simulation */\\r\\n\\t\\tthis.iterations = iterations;\\r\\n\\t\\t/* usually constant, however for delta time engines it fluctuates */\\r\\n\\t\\tthis.timestep = 1;\\r\\n\\t\\t/* global gravity value */\\r\\n\\t\\tthis.globalGravity = new Vector(0, 9.8 / 50);\\r\\n\\t\\t/* the amount of cells that the collision detection algorithms is allowed to sort into */\\r\\n\\t\\tthis.collisionGridCellsX = gridCellsX;\\r\\n\\t\\tthis.collisionGridCellsY = gridCellsY;\\r\\n\\t\\t/* amount of points that the rigid body allocation algorithm checks */\\r\\n\\t\\t/* by default checks 8 points, the 4 cardinal directions and the diagonals */\\r\\n\\t\\tthis.xs = [1, Math.SQRT1_2, 0, -Math.SQRT1_2, -1, Math.SQRT1_2, 0, Math.SQRT1_2];\\r\\n\\t\\tthis.ys = [0, Math.SQRT1_2, 1, Math.SQRT1_2, 0, -Math.SQRT1_2, -1, -Math.SQRT1_2];\\r\\n\\t\\t/* value between [0, 1] \\r\\n\\t\\t *\\twhere 0 is no correction, however this can cause objects to phase through each other\\r\\n\\t\\t *\\tand 1 is complete correction, however this can cause extreme jittering\\r\\n\\t\\t *\\t0.25 is the default value\\r\\n\\t\\t */\\r\\n\\t\\tthis.errorCorrectionCoefficient = 0.5;\\r\\n\\r\\n\\t\\t/* profiling */\\r\\n\\t\\tthis.collisions = 0;\\r\\n\\t\\tthis.collisionChecks = 0;\\r\\n\\r\\n\\t\\tthis.Line = class Line {\\r\\n\\t\\t\\tconstructor(x1 = 0, y1 = 0, x2 = 0, y2 = 0) {\\r\\n\\t\\t\\t\\tthis.x1 = x1;\\r\\n\\t\\t\\t\\tthis.y1 = y1;\\r\\n\\t\\t\\t\\tthis.x2 = x2;\\r\\n\\t\\t\\t\\tthis.y2 = y2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\tisRectRectColliding(rectangleX1, rectangleY1, rectangleWidth1, rectangleHeight1, rectangleX2, rectangleY2, rectangleWidth2, rectangleHeight2) {\\r\\n\\t\\tif (Math.abs(rectangleX1 - rectangleX2) > (rectangleWidth1 + rectangleWidth2) / 2) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t\\tif (Math.abs(rectangleY1 - rectangleY2) > (rectangleHeight1 + rectangleHeight2) / 2) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\tgetClosestEdge(circleX, circleY, rectangleX, rectangleY, rectangleWidth, rectangleHeight) {\\r\\n\\t\\tlet widthOver2 = rectangleWidth / 2;\\r\\n\\t\\tlet heightOver2 = rectangleHeight / 2;\\r\\n\\t\\t/* determine which edge is the closest */\\r\\n\\t\\t/* in order top, bottom, left, right */\\r\\n\\t\\tif (circleY < rectangleY - heightOver2) {\\r\\n\\t\\t\\treturn \\\"top\\\";\\r\\n\\t\\t}\\r\\n\\t\\tif (circleY > rectangleY + heightOver2) {\\r\\n\\t\\t\\treturn \\\"bottom\\\";\\r\\n\\t\\t}\\r\\n\\t\\tif (circleX < rectangleX - widthOver2) {\\r\\n\\t\\t\\treturn \\\"left\\\";\\r\\n\\t\\t}\\r\\n\\t\\tif (circleX > rectangleX + widthOver2) {\\r\\n\\t\\t\\treturn \\\"right\\\";\\r\\n\\t\\t}\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\tisCircleRectColliding(circleX, circleY, radius, rectangleX, rectangleY, rectangleWidth, rectangleHeight) {\\r\\n\\t\\tlet widthOver2 = rectangleWidth / 2;\\r\\n\\t\\tlet heightOver2 = rectangleHeight / 2;\\r\\n\\t\\tlet testX = circleX;\\r\\n\\t\\tlet testY = circleY;\\r\\n\\t\\t/* determine which edge is the closest */\\r\\n\\t\\t/* in order top, bottom, left, right */\\r\\n\\t\\tif (circleY < rectangleY - heightOver2) {\\r\\n\\t\\t\\ttestY = rectangleY - heightOver2;\\r\\n\\t\\t} else if (circleY > rectangleY + heightOver2) {\\r\\n\\t\\t\\ttestY = rectangleY + heightOver2;\\r\\n\\t\\t}\\r\\n\\t\\tif (circleX < rectangleX - widthOver2) {\\r\\n\\t\\t\\ttestX = rectangleX - widthOver2;\\r\\n\\t\\t} else if (circleX > rectangleX + widthOver2) {\\r\\n\\t\\t\\ttestX = rectangleX + widthOver2;\\r\\n\\t\\t}\\r\\n\\t\\t/* get distance from closest edges */\\r\\n\\t\\tlet distance = Utils.fastDist(testX, testY, circleX, circleY);\\r\\n\\t\\t/* if the distance is less than the radius square (a^2 + b^2 = c^2) then a collision has happened */\\r\\n\\t\\tif (distance <= radius ** 2) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\tisLineCircleColliding(x1, y1, x2, y2, cx, cy, r) {\\r\\n\\t\\t/* if either end is in the circle, return true immediately */\\r\\n\\t\\tlet inside1 = this.isPointCircleColliding(x1, y1, cx, cy, r);\\r\\n\\t\\tlet inside2 = this.isPointCircleColliding(x2, y2, cx, cy, r);\\r\\n\\t\\tif (inside1 || inside2) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\tlet closest = this.getClosestPoint(x1, y1, x2, y2, cx, cy);\\r\\n\\t\\tlet onSegment = this.isLinePointColliding(x1, y1, x2, y2, closest.x, closest.y);\\r\\n\\t\\tif (onSegment === false) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t};\\r\\n\\t\\t/* get distance to closest point */\\r\\n\\t\\tif (Utils.fastDist(cx, cy, closest.x, closest.y) <= r ** 2) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\tdistanceLinePoint(x1, y1, x2, y2, cx, cy) {\\r\\n\\t\\tlet closest = this.getClosestPoint(x1, y1, x2, y2, cx, cy);\\r\\n\\t\\tlet onSegment = this.isLinePointColliding(x1, y1, x2, y2, closest.x, closest.y);\\r\\n\\t\\tif (onSegment === false) {\\r\\n\\t\\t\\treturn Math.sqrt(Math.min(Utils.fastDist(cx, cy, x1, y1), Utils.fastDist(cx, cy, x2, y2)));\\r\\n\\t\\t}\\r\\n\\t\\t/* get distance to closest point */\\r\\n\\t\\treturn Utils.dist(cx, cy, closest.x, closest.y);\\r\\n\\t}\\r\\n\\tgetClosestPoint(x1, y1, x2, y2, cx, cy) {\\r\\n\\t\\t/* get length of the line */\\r\\n\\t\\tlet len = Utils.fastDist(x1, y1, x2, y2);\\r\\n\\t\\t/* get dot product of the line and circle */\\r\\n\\t\\tlet dot = (((cx - x1) * (x2 - x1)) + ((cy - y1) * (y2 - y1))) / len;\\r\\n\\t\\t/* find the closest point on the line */\\r\\n\\t\\tlet closestX = x1 + (dot * (x2 - x1));\\r\\n\\t\\tlet closestY = y1 + (dot * (y2 - y1));\\r\\n\\t\\treturn new Vector(closestX, closestY);\\r\\n\\t}\\r\\n\\t/* extremely fast method for finding if a point circle collides */\\r\\n\\tisPointCircleColliding(px, py, cx, cy, r) {\\r\\n\\t\\tif (Utils.fastDist(px, py, cx, cy) <= r ** 2) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\tisLinePointColliding(x1, y1, x2, y2, px, py) {\\r\\n\\t\\t/* get distance from the point to the two ends of the line */\\r\\n\\t\\tlet d1 = Utils.dist(px, py, x1, y1);\\r\\n\\t\\tlet d2 = Utils.dist(px, py, x2, y2);\\r\\n\\t\\t/* get the length of the line */\\r\\n\\t\\tlet lineLen = Utils.dist(x1, y1, x2, y2);\\r\\n\\t\\t/* usually constant, higher buffer gives more zoning but less accuracy */\\r\\n\\t\\tlet buffer = 0.1;\\r\\n\\t\\t/* if the distance between the points is equal to the lines length plus minus the buffer then it is exactly on the line*/\\r\\n\\t\\tif (d1 + d2 >= lineLen - buffer && d1 + d2 <= lineLen + buffer) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\tgenerateEdgeLine(edgeName, x, y, width, height) {\\r\\n\\t\\tlet edgeLine = new this.Line();\\r\\n\\t\\tswitch (edgeName) {\\r\\n\\t\\t\\tcase \\\"left\\\": {\\r\\n\\t\\t\\t\\tedgeLine.x1 = x - width / 2;\\r\\n\\t\\t\\t\\tedgeLine.y1 = y - height / 2;\\r\\n\\t\\t\\t\\tedgeLine.x2 = x - width / 2;\\r\\n\\t\\t\\t\\tedgeLine.y2 = y + height / 2;\\r\\n\\t\\t\\t\\tbreak;\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase \\\"right\\\": {\\r\\n\\t\\t\\t\\tedgeLine.x1 = x + width / 2;\\r\\n\\t\\t\\t\\tedgeLine.y1 = y - height / 2;\\r\\n\\t\\t\\t\\tedgeLine.x2 = x + width / 2;\\r\\n\\t\\t\\t\\tedgeLine.y2 = y + height / 2;\\r\\n\\t\\t\\t\\tbreak;\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase \\\"top\\\": {\\r\\n\\t\\t\\t\\tedgeLine.x1 = x - width / 2;\\r\\n\\t\\t\\t\\tedgeLine.y1 = y - height / 2;\\r\\n\\t\\t\\t\\tedgeLine.x2 = x + width / 2;\\r\\n\\t\\t\\t\\tedgeLine.y2 = y - height / 2;\\r\\n\\t\\t\\t\\tbreak;\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase \\\"bottom\\\": {\\r\\n\\t\\t\\t\\tedgeLine.x1 = x - width / 2;\\r\\n\\t\\t\\t\\tedgeLine.y1 = y + height / 2;\\r\\n\\t\\t\\t\\tedgeLine.x2 = x + width / 2;\\r\\n\\t\\t\\t\\tedgeLine.y2 = y + height / 2;\\r\\n\\t\\t\\t\\tbreak;\\t\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn edgeLine;\\r\\n\\t}\\r\\n\\tsquareCollisionAngle(closestEdge) {\\r\\n\\t\\tswitch (closestEdge) {\\r\\n\\t\\t\\tcase \\\"left\\\": {\\r\\n\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase \\\"right\\\": {\\r\\n\\t\\t\\t\\treturn Math.PI;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase \\\"top\\\": {\\r\\n\\t\\t\\t\\treturn Math.PI / 2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase \\\"bottom\\\": {\\r\\n\\t\\t\\t\\treturn -Math.PI / 2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tdistanceBetweenAABB(rectangleX1, rectangleY1, rectangleWidth1, rectangleHeight1, rectangleX2, rectangleY2, rectangleWidth2, rectangleHeight2) {\\r\\n\\t\\tlet halfWidth1 = rectangleWidth1 / 2;\\r\\n\\t\\tlet halfWidth2 = rectangleWidth2 / 2;\\r\\n\\t\\tlet halfHeight1 = rectangleHeight1 / 2;\\r\\n\\t\\tlet halfHeight2 = rectangleHeight2 / 2;\\r\\n\\t\\tlet left = Math.min(rectangleX1 + halfWidth1, rectangleX2 + halfWidth2);\\r\\n\\t\\tlet top = Math.min(rectangleY1 + halfHeight1, rectangleY2 + halfHeight2);\\r\\n\\t\\tlet right = Math.max(rectangleX1 - halfWidth1, rectangleX2 - halfWidth2);\\r\\n\\t\\tlet bottom = Math.max(rectangleY1 - halfHeight1, rectangleY2 - halfHeight2);\\r\\n\\t\\tlet width = left - right;\\r\\n\\t\\tlet height = top - bottom;\\r\\n\\t\\treturn Math.min(width, height);\\r\\n\\t}\\r\\n\\tclosestEdgeAngle(point, rect) {\\r\\n\\t\\tlet transformPoint = point.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet transformRect = rect.getComponent(\\\"transform\\\");\\r\\n\\t\\tif (transformRect.scaleX / 2 === transformRect.scaleY / 2) {\\r\\n\\t\\t\\tlet angle = Utils.direction(transformPoint.x, transformPoint.y, transformRect.x, transformRect.y);\\r\\n\\t\\t\\tif (angle > -Math.PI / 4 && angle < Math.PI / 4) {\\r\\n\\t\\t\\t\\treturn 0;\\t\\r\\n\\t\\t\\t} else if (angle > Math.PI / 2 - Math.PI / 4 && angle < Math.PI / 2 + Math.PI / 4) {\\r\\n\\t\\t\\t\\treturn Math.PI / 2;\\r\\n\\t\\t\\t} else if (angle > -Math.PI / 2 - Math.PI / 4 && angle < -Math.PI / 2 + Math.PI / 4) {\\r\\n\\t\\t\\t\\treturn -Math.PI / 2;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn Math.PI;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else if (transformRect.scaleX / 2 > transformRect.scaleY / 2) {\\r\\n\\t\\t\\tlet leftPoint = new Vector(transformRect.x - transformRect.scaleX / 2 + transformRect.scaleY / 2, transformRect.y);\\r\\n\\t\\t\\tlet rightPoint = new Vector(transformRect.x + transformRect.scaleX / 2 - transformRect.scaleY / 2, transformRect.y);\\r\\n\\t\\t\\tlet leftPointDistance = Utils.fastDist(transformPoint.x - transformRect.scaleX / 2, transformPoint.y, leftPoint.x, leftPoint.y);\\r\\n\\t\\t\\tlet rightPointDistance = Utils.fastDist(transformPoint.x + transformRect.scaleX / 2, transformPoint.y, rightPoint.x, rightPoint.y);\\r\\n\\t\\t\\tif (leftPointDistance < rightPointDistance) {\\r\\n\\t\\t\\t\\tlet dir = Utils.direction(transformPoint.x - transformRect.scaleX / 2, transformPoint.y, leftPoint.x, leftPoint.y);\\r\\n\\t\\t\\t\\tif (Math.abs(dir) < Math.PI / 4) {\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tlet dir = Utils.direction(transformPoint.x + transformRect.scaleX / 2, transformPoint.y, rightPoint.x, rightPoint.y);\\r\\n\\t\\t\\t\\tif (Math.abs(dir) > Math.PI * 3 / 4) {\\r\\n\\t\\t\\t\\t\\treturn Math.PI;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tlet dir = Utils.direction(transformPoint.x, transformPoint.y, transformRect.x, transformRect.y);\\r\\n\\t\\t\\treturn Math.sign(dir) * Math.PI / 2;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tlet leftPoint = new Vector(transformRect.x, transformRect.y - transformRect.scaleY / 2 + transformRect.scaleX / 2);\\r\\n\\t\\t\\tlet rightPoint = new Vector(transformRect.x, transformRect.y + transformRect.scaleY / 2 - transformRect.scaleX / 2);\\r\\n\\t\\t\\tlet leftPointDistance = Utils.fastDist(transformPoint.x, transformPoint.y - transformRect.scaleY / 2, leftPoint.x, leftPoint.y);\\r\\n\\t\\t\\tlet rightPointDistance = Utils.fastDist(transformPoint.x, transformPoint.y + transformRect.scaleY / 2, rightPoint.x, rightPoint.y);\\r\\n\\t\\t\\tif (leftPointDistance < rightPointDistance) {\\r\\n\\t\\t\\t\\tlet dir = Utils.direction(transformPoint.x, transformPoint.y - transformRect.scaleY / 2, leftPoint.x, leftPoint.y);\\r\\n\\t\\t\\t\\tif (dir > Math.PI / 4 && dir < Math.PI * 3 / 4) {\\r\\n\\t\\t\\t\\t\\treturn Math.PI / 2;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tlet dir = Utils.direction(transformPoint.x, transformPoint.y + transformRect.scaleX / 2, rightPoint.x, rightPoint.y);\\r\\n\\t\\t\\t\\tif (dir < -Math.PI / 4 && dir > -Math.PI * 3 / 4) {\\r\\n\\t\\t\\t\\t\\treturn -Math.PI / 2;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tlet dir = Utils.direction(transformPoint.x, transformPoint.y, transformRect.x, transformRect.y);\\r\\n\\t\\t\\treturn Math.round(dir / Math.PI) * Math.PI;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tresizeBounds(width, height) {\\r\\n\\t\\tthis.width = width;\\r\\n\\t\\tthis.height = height;\\r\\n\\t\\tthis.xOffset = width / 2;\\r\\n\\t\\tthis.yOffset = height / 2;\\r\\n\\t}\\r\\n\\tgridCells(x, y) {\\r\\n\\t\\tthis.collisionGridCellsX = x;\\r\\n\\t\\tthis.collisionGridCellsY = y;\\r\\n\\t}\\r\\n\\tgridSize(size) {\\r\\n\\t\\tthis.collisionGridCellsX = Math.ceil(this.width / size);\\r\\n\\t\\tthis.collisionGridCellsY = Math.ceil(this.height / size);\\r\\n\\t}\\r\\n\\tintegrate(dt, object) {\\r\\n\\t\\tlet transform = object.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet rigidbody = object.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\t/* prevent integration and reset derivative values for static objects */\\r\\n\\t\\tif (rigidbody.isStatic) {\\r\\n\\t\\t\\trigidbody.velocityX = 0;\\r\\n\\t\\t\\trigidbody.velocityY = 0;\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\t/* bounds checking for objects */\\r\\n\\t\\tlet sizeX = 0;\\r\\n\\t\\tlet sizeY = 0;\\r\\n\\t\\tif (rigidbody.type === \\\"circle\\\") {\\r\\n\\t\\t\\tlet max = Math.max(transform.scaleX, transform.scaleY) / 2;\\r\\n\\t\\t\\tsizeX = max;\\r\\n\\t\\t\\tsizeY = max;\\r\\n\\t\\t} else if (rigidbody.type === \\\"rectangle\\\") {\\r\\n\\t\\t\\tsizeX = transform.scaleX / 2;\\r\\n\\t\\t\\tsizeY = transform.scaleY / 2;\\r\\n\\t\\t}\\r\\n\\t\\tlet restitution = rigidbody.restitution;\\r\\n\\t\\tlet friction = 1 - (1 - restitution) ** this.iterations;\\r\\n\\t\\tlet XPositionOnNextStep = transform.x + rigidbody.velocityX * dt;\\r\\n\\t\\tlet YPositionOnNextStep = transform.y + rigidbody.velocityY * dt;\\r\\n\\t\\t/* bounds check for left side of screen */\\r\\n\\t\\tif (XPositionOnNextStep < sizeX - this.xOffset) {\\r\\n\\t\\t\\trigidbody.velocityX *= -restitution;\\r\\n\\t\\t\\t/* apply object friction */\\r\\n\\t\\t\\trigidbody.velocityY *= friction;\\r\\n\\t\\t\\ttransform.x = sizeX - this.xOffset;\\r\\n\\t\\t}\\r\\n\\t\\t/* bounds check for right side of screen */\\r\\n\\t\\tif (XPositionOnNextStep > this.width - sizeX - this.xOffset) {\\r\\n\\t\\t\\trigidbody.velocityX *= -restitution;\\r\\n\\t\\t\\t/* apply object friction */\\r\\n\\t\\t\\trigidbody.velocityY *= friction;\\r\\n\\t\\t\\ttransform.x = this.width - sizeX - this.xOffset;\\r\\n\\t\\t}\\r\\n\\t\\t/* bounds check for top side of screen */\\r\\n\\t\\tif (YPositionOnNextStep < sizeY - this.yOffset) {\\r\\n\\t\\t\\trigidbody.velocityY *= -restitution;\\r\\n\\t\\t\\t/* apply object friction */\\r\\n\\t\\t\\trigidbody.velocityX *= friction;\\r\\n\\t\\t\\ttransform.y = sizeY - this.yOffset;\\r\\n\\t\\t}\\r\\n\\t\\t/* bounds check for bottom of screen */\\r\\n\\t\\tif (YPositionOnNextStep > this.height - sizeY - this.yOffset) {\\r\\n\\t\\t\\trigidbody.velocityY *= -restitution;\\r\\n\\t\\t\\t/* apply object friction */\\r\\n\\t\\t\\trigidbody.velocityX *= friction;\\r\\n\\t\\t\\ttransform.y = this.height - sizeY - this.yOffset;\\r\\n\\t\\t}\\r\\n\\t\\t/* verlet integration */\\r\\n\\t\\tlet newPosX = transform.x + rigidbody.velocityX * dt + rigidbody.accelerationX * (dt * dt * 0.5);\\r\\n\\t\\tlet newPosY = transform.y + rigidbody.velocityY * dt + rigidbody.accelerationY * (dt * dt * 0.5);\\r\\n\\t\\tlet newVelX = rigidbody.velocityX + (rigidbody.accelerationX + this.globalGravity.x) * dt;\\r\\n\\t\\tlet newVelY = rigidbody.velocityY + (rigidbody.accelerationY + this.globalGravity.y) * dt;\\r\\n\\t\\t/* update new values */\\r\\n\\t\\ttransform.x = newPosX;\\r\\n\\t\\ttransform.y = newPosY;\\r\\n\\t\\trigidbody.velocityX = newVelX * 0.999;\\r\\n\\t\\trigidbody.velocityY = newVelY * 0.999;\\r\\n\\t}\\r\\n\\t/*\\r\\n\\t *\\tallocated rigid bodies into grid sections to reduce collision detection time \\r\\n\\t *\\tobjects can be in more than 1 grid cell at a time\\r\\n\\t */\\r\\n\\tallocateRigidbodies(objects) {\\r\\n\\t\\tlet collisionGrid = [];\\r\\n\\t\\t/* fill collision grid array with empty arrays */\\r\\n\\t\\tfor (let i = 0, len = this.collisionGridCellsX * this.collisionGridCellsY; i < len; i++) {\\r\\n\\t\\t\\tcollisionGrid.push([]);\\r\\n\\t\\t}\\r\\n\\t\\t/* loop across every object */\\r\\n\\t\\tfor (let index = 0; index < objects.length; index++) {\\r\\n\\t\\t\\tlet rigidbody = objects[index].getComponent(\\\"rigidbody\\\");\\r\\n\\t\\t\\tlet transform = objects[index].getComponent(\\\"transform\\\");\\r\\n\\t\\t\\t/* ignore if the object is not expected to collide */\\r\\n\\t\\t\\tif (rigidbody.isColliding === false) continue;\\r\\n\\t\\t\\t/* ignore if the object is not allocatable */\\r\\n\\t\\t\\tif (rigidbody.type === \\\"line\\\") continue;\\r\\n\\t\\t\\tif (rigidbody.type === \\\"circle\\\") {\\r\\n\\t\\t\\t\\tlet indexes = [];\\r\\n\\t\\t\\t\\tfor (let j = 0, len = this.xs.length; j < len; j++) {\\r\\n\\t\\t\\t\\t\\t/* map the x and y values of an object to between a grid */\\r\\n\\t\\t\\t\\t\\tlet max = Math.max(transform.scaleX, transform.scaleY) / 2;\\r\\n\\t\\t\\t\\t\\tlet x = Math.floor(Utils.map(transform.x + max * this.xs[j], -this.width / 2, this.width / 2, 0, this.collisionGridCellsX));\\r\\n\\t\\t\\t\\t\\tlet y = Math.floor(Utils.map(transform.y + max * this.ys[j], -this.width / 2, this.width / 2, 0, this.collisionGridCellsY));\\r\\n\\t\\t\\t\\t\\tthis.addToCollisionGrid(collisionGrid, x, y, indexes, index);\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else if (rigidbody.type === \\\"rectangle\\\") {\\r\\n\\t\\t\\t\\tlet gridSizeX = (this.width / this.collisionGridCellsX);\\r\\n\\t\\t\\t\\tlet gridSizeY = (this.height / this.collisionGridCellsY);\\r\\n\\t\\t\\t\\tlet gridCellsXSpan = Math.ceil(transform.scaleX / gridSizeX);\\r\\n\\t\\t\\t\\tlet gridCellsYSpan = Math.ceil(transform.scaleY / gridSizeY);\\r\\n\\t\\t\\t\\tlet indexes = [];\\r\\n\\t\\t\\t\\tfor (let i = 0; i < gridCellsXSpan + 1; i++) {\\r\\n\\t\\t\\t\\t\\tfor (let j = 0; j < gridCellsYSpan + 1; j++) {\\r\\n\\t\\t\\t\\t\\t\\tlet x = Math.floor(Utils.map(transform.x - gridSizeX * gridCellsXSpan / 2 + gridSizeX * i, -this.width / 2, this.width / 2, 0, this.collisionGridCellsX));\\r\\n\\t\\t\\t\\t\\t\\tlet y = Math.floor(Utils.map(transform.y - gridSizeY * gridCellsYSpan / 2 + gridSizeY * j, -this.width / 2, this.width / 2, 0, this.collisionGridCellsY));\\r\\n\\t\\t\\t\\t\\t\\tthis.addToCollisionGrid(collisionGrid, x, y, indexes, index);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn collisionGrid;\\r\\n\\t}\\r\\n\\taddToCollisionGrid(grid, x, y, indexes, index) {\\r\\n\\t\\t/* bounds checks for object (including NaN error detection) */\\r\\n\\t\\tif (x < 0) x = 0;\\r\\n\\t\\tif (y < 0) y = 0;\\r\\n\\t\\tif (x > this.collisionGridCellsX - 1) x = this.collisionGridCellsX - 1;\\r\\n\\t\\tif (y > this.collisionGridCellsY - 1) y = this.collisionGridCellsY - 1;\\r\\n\\t\\tlet objectHasntBeenPushed = true;\\r\\n\\t\\t/* if the object exists already in this grid area, ignore it */\\r\\n\\t\\tfor (let k = 0, len = indexes.length; k < len; k += 2) {\\r\\n\\t\\t\\tif (indexes[k] === x && indexes[k + 1] === y) {\\r\\n\\t\\t\\t\\tobjectHasntBeenPushed = false;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t/* push object to grid if it hasn't already been */\\r\\n\\t\\tif (objectHasntBeenPushed) {\\r\\n\\t\\t\\t/* catching NaN errors which cause critical program errors */\\r\\n\\t\\t\\ttry {\\r\\n\\t\\t\\t\\tgrid[y * this.collisionGridCellsX + x].push(index);\\r\\n\\t\\t\\t\\tindexes.push(x, y);\\r\\n\\t\\t\\t} catch (e) {\\r\\n\\t\\t\\t\\tconsole.warn(\\\"dumping stack trace\\\");\\r\\n\\t\\t\\t\\tconsole.warn(\\\"x: \\\" + x);\\r\\n\\t\\t\\t\\tconsole.warn(\\\"y: \\\" + y);\\r\\n\\t\\t\\t\\tthrow new Error(\\\"Potato Engine Allocation ERROR: \\\" + e);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tisColliding(o1, o2) {\\r\\n\\t\\tlet rigidbodyo1 = o1.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo1 = o1.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet rigidbodyo2 = o2.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo2 = o2.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet max1 = Math.max(transformo1.scaleX, transformo1.scaleY) / 2;\\r\\n\\t\\tlet max2 = Math.max(transformo2.scaleX, transformo2.scaleY) / 2;\\r\\n\\t\\tif (rigidbodyo1.type === \\\"circle\\\" && rigidbodyo2.type === \\\"circle\\\") {\\r\\n\\t\\t\\t/* approximate the distance using a fast distance estimation (without square root) to save performance */\\r\\n\\t\\t\\treturn Utils.fastDist(transformo1.x, transformo1.y, transformo2.x, transformo2.y) <= Math.pow(max1 + max2, 2);\\r\\n\\t\\t} else if (((rigidbodyo1.type === \\\"circle\\\" && rigidbodyo2.type === \\\"rectangle\\\") || (rigidbodyo1.type === \\\"rectangle\\\" && rigidbodyo2.type === \\\"circle\\\"))) {\\r\\n\\t\\t\\tif (rigidbodyo1.type === \\\"circle\\\") {\\r\\n\\t\\t\\t\\treturn this.isCircleRectColliding(transformo1.x, transformo1.y, max1, transformo2.x, transformo2.y, transformo2.scaleX, transformo2.scaleY);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn this.isCircleRectColliding(transformo2.x, transformo2.y, max2, transformo1.x, transformo1.y, transformo1.scaleX, transformo1.scaleY);\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else if (rigidbodyo1.type === \\\"rectangle\\\" && rigidbodyo2.type === \\\"rectangle\\\") {\\r\\n\\t\\t\\treturn this.isRectRectColliding(transformo1.x, transformo1.y, transformo1.scaleX, transformo1.scaleY, transformo2.x, transformo2.y, transformo2.scaleX, transformo2.scaleY);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tcalculateMassRatio(o1, o2) {\\r\\n\\t\\tlet rigidbodyo1 = o1.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo1 = o1.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet rigidbodyo2 = o2.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo2 = o2.getComponent(\\\"transform\\\");\\r\\n\\t\\t/* calculate mass from density */\\r\\n\\t\\tlet masso1 = ((rigidbodyo1.type === \\\"circle\\\") ? Math.PI * Math.max(transformo1.scaleX, transformo1.scaleY) ** 2 : transformo1.scaleX * transformo1.scaleY) * rigidbodyo1.density;\\r\\n\\t\\tlet masso2 = ((rigidbodyo2.type === \\\"circle\\\") ? Math.PI * Math.max(transformo2.scaleX, transformo2.scaleY) ** 2 : transformo2.scaleX * transformo2.scaleY) * rigidbodyo2.density;\\r\\n\\t\\t/* calculate the square rooted mass ratio */\\r\\n\\t\\tlet massRatio = Math.log(Math.max(masso1, masso2) / Math.min(masso1, masso2) + 1) / Math.log(2);\\r\\n\\t\\treturn ((masso1 > masso2) ? 1 / massRatio : massRatio);\\r\\n\\t}\\r\\n\\tresolveCircleCircle(o1, o2) {\\r\\n\\t\\tlet rigidbodyo1 = o1.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo1 = o1.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet rigidbodyo2 = o2.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo2 = o2.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet max1 = Math.max(transformo1.scaleX, transformo1.scaleY) / 2;\\r\\n\\t\\tlet max2 = Math.max(transformo2.scaleX, transformo2.scaleY) / 2;\\r\\n\\t\\t/* impulse resolution */\\r\\n\\t\\t/* get angle between objects */\\r\\n\\t\\tlet angle = Utils.direction(transformo1.x, transformo1.y, transformo2.x, transformo2.y);\\r\\n\\t\\t/* get true distance between objects */\\r\\n\\t\\tlet dist = Utils.dist(transformo1.x, transformo1.y, transformo2.x, transformo2.y) - max1 - max2;\\r\\n\\t\\t/* generate x and y from magnitude and direction */\\r\\n\\t\\treturn new VectorFromAngle(angle, dist);\\r\\n\\t}\\r\\n\\t/* o1 must be a circle and o2 must be a rectangle */\\r\\n\\tresolveCircleRect(o1, o2) {\\r\\n\\t\\tlet rigidbodyo1 = o1.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo1 = o1.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet rigidbodyo2 = o2.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo2 = o2.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet max1 = Math.max(transformo1.scaleX, transformo1.scaleY) / 2;\\r\\n\\t\\tlet closestEdge = this.getClosestEdge(transformo1.x, transformo1.y, transformo2.x, transformo2.y, transformo2.scaleX, transformo2.scaleY);\\r\\n\\t\\tif (closestEdge !== null) {\\t\\t\\t\\r\\n\\t\\t\\tlet useLine = this.generateEdgeLine(closestEdge, transformo2.x, transformo2.y, transformo2.scaleX, transformo2.scaleY);\\r\\n\\t\\t\\tlet distanceToLine = this.distanceLinePoint(useLine.x1, useLine.y1, useLine.x2, useLine.y2, transformo1.x, transformo1.y) - max1;\\r\\n\\t\\t\\tlet closestPoint = this.getClosestPoint(useLine.x1, useLine.y1, useLine.x2, useLine.y2, transformo1.x, transformo1.y);\\r\\n\\t\\t\\tlet angle = this.squareCollisionAngle(closestEdge);\\r\\n\\t\\t\\tif (angle === Math.PI || angle === 0) {\\r\\n\\t\\t\\t\\trigidbodyo1.velocityY *= rigidbodyo2.surfaceFriction;\\r\\n\\t\\t\\t\\trigidbodyo2.velocityY *= rigidbodyo2.surfaceFriction;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\trigidbodyo1.velocityX *= rigidbodyo2.surfaceFriction;\\r\\n\\t\\t\\t\\trigidbodyo2.velocityX *= rigidbodyo2.surfaceFriction;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn new VectorFromAngle(angle, distanceToLine);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t/* object is within the center of the square, use normal circle-circle collisions to push it out */\\r\\n\\t\\t\\t/* impulse resolution */\\r\\n\\t\\t\\t/* get angle between objects */\\r\\n\\t\\t\\tlet angle = Utils.direction(transformo1.x, transformo1.y, transformo2.x, transformo2.y);\\r\\n\\t\\t\\t/* get true distance between objects */\\r\\n\\t\\t\\tlet dist = Utils.dist(transformo1.x, transformo1.y, transformo2.x, transformo2.y) - max1;\\r\\n\\t\\t\\t/* generate x and y from magnitude and direction */\\r\\n\\t\\t\\treturn new VectorFromAngle(angle, dist);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tresolveRectRect(o1, o2) {\\r\\n\\t\\tlet rigidbodyo1 = o1.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo1 = o1.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet rigidbodyo2 = o2.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo2 = o2.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet angle = this.closestEdgeAngle(o2, o1);\\r\\n\\t\\tif (Math.abs(angle) === Math.PI || angle === 0) {\\r\\n\\t\\t\\trigidbodyo1.velocityY *= rigidbodyo2.surfaceFriction;\\r\\n\\t\\t\\trigidbodyo2.velocityY *= rigidbodyo2.surfaceFriction;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\trigidbodyo1.velocityX *= rigidbodyo1.surfaceFriction;\\r\\n\\t\\t\\trigidbodyo2.velocityX *= rigidbodyo1.surfaceFriction;\\r\\n\\t\\t}\\r\\n\\t\\tlet distance = this.distanceBetweenAABB(transformo1.x, transformo1.y, transformo1.scaleX, transformo1.scaleY, transformo2.x, transformo2.y, transformo2.scaleX, transformo2.scaleY);\\r\\n\\t\\treturn new VectorFromAngle(angle, distance);\\r\\n\\t}\\r\\n\\tresolveCollision(o1, o2) {\\r\\n\\t\\tlet rigidbodyo1 = o1.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet rigidbodyo2 = o2.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tif (rigidbodyo1.type === \\\"circle\\\" && rigidbodyo2.type === \\\"circle\\\") {\\r\\n\\t\\t\\treturn this.resolveCircleCircle(o1, o2);\\r\\n\\t\\t} else if (((rigidbodyo1.type === \\\"circle\\\" && rigidbodyo2.type === \\\"rectangle\\\") || (rigidbodyo1.type === \\\"rectangle\\\" && rigidbodyo2.type === \\\"circle\\\"))) {\\r\\n\\t\\t\\t\\treturn this.resolveCircleRect(o1, o2);\\r\\n\\t\\t} else if (rigidbodyo1.type === \\\"rectangle\\\" && rigidbodyo2.type === \\\"rectangle\\\") {\\r\\n\\t\\t\\t\\treturn this.resolveRectRect(o1, o2);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t/* default case if the physics engine cannot handle this type of collision */\\r\\n\\t\\t\\treturn new Vector();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tapplyImpulse(impulse, massRatio, o1, o2) {\\r\\n\\t\\tlet rigidbodyo1 = o1.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo1 = o1.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet rigidbodyo2 = o2.getComponent(\\\"rigidbody\\\");\\r\\n\\t\\tlet transformo2 = o2.getComponent(\\\"transform\\\");\\r\\n\\t\\tif (rigidbodyo1.isStatic === false) {\\r\\n\\t\\t\\t/* subtract impulse to velocity */\\r\\n\\t\\t\\trigidbodyo1.velocityX += impulse.x * (1 - rigidbodyo1.restitution) * massRatio;\\r\\n\\t\\t\\trigidbodyo1.velocityY += impulse.y * (1 - rigidbodyo1.restitution) * massRatio;\\r\\n\\t\\t\\t/* subtract impulse to position */\\r\\n\\t\\t\\ttransformo1.x += impulse.x * this.errorCorrectionCoefficient * massRatio;\\r\\n\\t\\t\\ttransformo1.y += impulse.y * this.errorCorrectionCoefficient * massRatio;\\r\\n\\t\\t}\\r\\n\\t\\tif (rigidbodyo2.isStatic === false) {\\r\\n\\t\\t\\t/* add impulse to velocity */\\r\\n\\t\\t\\trigidbodyo2.velocityX -= impulse.x * (1 - rigidbodyo2.restitution) / massRatio;\\r\\n\\t\\t\\trigidbodyo2.velocityY -= impulse.y * (1 - rigidbodyo2.restitution) / massRatio;\\r\\n\\t\\t\\t/* add impulse to position */\\r\\n\\t\\t\\ttransformo2.x -= impulse.x * this.errorCorrectionCoefficient / massRatio;\\r\\n\\t\\t\\ttransformo2.y -= impulse.y * this.errorCorrectionCoefficient / massRatio;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tdetectCollisions(objects, collisionGrid) {\\r\\n\\t\\t/* if only 1 object exists in the collision grid, then ignore */\\r\\n\\t\\tfor (let i = 0, len = collisionGrid.length; i < len; i++) {\\r\\n\\t\\t\\tif (collisionGrid[i].length <= 1) {\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tlet len2 = collisionGrid[i].length;\\r\\n\\t\\t\\tfor (let j = 0; j < len2; j++) {\\r\\n\\t\\t\\t\\tfor (let k = j + 1; k < len2; k++) {\\r\\n\\t\\t\\t\\t\\tlet o1 = objects[collisionGrid[i][j]];\\r\\n\\t\\t\\t\\t\\tlet o2 = objects[collisionGrid[i][k]];\\r\\n\\t\\t\\t\\t\\t/* ignore collision detection between static objects if they are both static */\\r\\n\\t\\t\\t\\t\\tif (o1.getComponent(\\\"rigidbody\\\").isStatic && o2.getComponent(\\\"rigidbody\\\").isStatic) {\\r\\n\\t\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tthis.collisionChecks++;\\r\\n\\t\\t\\t\\t\\tif (this.isColliding(o1, o2)) {\\r\\n\\t\\t\\t\\t\\t\\tthis.collisions++;\\r\\n\\t\\t\\t\\t\\t\\tlet massRatio = this.calculateMassRatio(o1, o2);\\r\\n\\t\\t\\t\\t\\t\\tif ((o2.getComponent(\\\"rigidbody\\\").type === \\\"circle\\\" && o1.getComponent(\\\"rigidbody\\\").type === \\\"rectangle\\\") || (o1.getComponent(\\\"rigidbody\\\").type === \\\"rectangle\\\" && o2.getComponent(\\\"rigidbody\\\").type === \\\"rectangle\\\" && o1.getComponent(\\\"transform\\\").scaleX * o1.getComponent(\\\"transform\\\").scaleY < o2.getComponent(\\\"transform\\\").scaleX * o2.getComponent(\\\"transform\\\").scaleY)) {\\r\\n\\t\\t\\t\\t\\t\\t\\tmassRatio = 1 / massRatio;\\r\\n\\t\\t\\t\\t\\t\\t\\tlet temp = o2;\\r\\n\\t\\t\\t\\t\\t\\t\\to2 = o1;\\r\\n\\t\\t\\t\\t\\t\\t\\to1 = temp;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tlet impulse = this.resolveCollision(o1, o2);\\r\\n\\t\\t\\t\\t\\t\\t/* in case of NaN calculation errors */\\r\\n\\t\\t\\t\\t\\t\\tif (isNaN(impulse.x)) {\\r\\n\\t\\t\\t\\t\\t\\t\\timpulse.y = 0;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tif ((isNaN(impulse.y))) {\\r\\n\\t\\t\\t\\t\\t\\t\\timpulse.y = 0;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tthis.applyImpulse(impulse, massRatio, o1, o2);\\r\\n\\t\\t\\t\\t\\t\\tif (o1.hasComponent(\\\"behaviour\\\")) {\\r\\n\\t\\t\\t\\t\\t\\t\\to1.getComponent(\\\"behaviour\\\").runEvent(\\\"collision\\\");\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tif (o2.hasComponent(\\\"behaviour\\\")) {\\r\\n\\t\\t\\t\\t\\t\\t\\to2.getComponent(\\\"behaviour\\\").runEvent(\\\"collision\\\");\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* to be called every frame by other functions */\\r\\n\\tstep(objects) {\\r\\n\\t\\tthis.collisions = 0;\\r\\n\\t\\tthis.collisionChecks = 0;\\r\\n\\t\\t/* calculate delta time to be used by the iteration engine */\\r\\n\\t\\tconst dt = this.timestep * (1 / this.iterations);\\r\\n\\t\\tlet validObjects = [];\\r\\n\\t\\tlet lineObjects = [];\\r\\n\\t\\tfor (let i = 0; i < objects.length; i++) {\\r\\n\\t\\t\\tif (objects[i].hasComponent(\\\"rigidbody\\\") && objects[i].hasComponent(\\\"transform\\\") ) {\\r\\n\\t\\t\\t\\tif (objects[i].getComponent(\\\"rigidbody\\\").type === \\\"rectangle\\\" || objects[i].getComponent(\\\"rigidbody\\\").type === \\\"circle\\\") {\\r\\n\\t\\t\\t\\t\\tvalidObjects.push(objects[i]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (objects[i].getComponent(\\\"rigidbody\\\").type === \\\"line\\\") {\\r\\n\\t\\t\\t\\t\\tlineObjects.push(objects[i]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tfor (let i = 0; i < this.iterations; i++) {\\r\\n\\t\\t\\t/* integrate all objects */\\r\\n\\t\\t\\tfor (let j = 0; j < validObjects.length; j++) {\\r\\n\\t\\t\\t\\tthis.integrate(dt, validObjects[j]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.detectLineCollisions(lineObjects, validObjects);\\r\\n\\t\\t\\t/* allocate rigid bodies into the grid */\\r\\n\\t\\t\\tlet collisionGrid = this.allocateRigidbodies(validObjects);\\r\\n\\t\\t\\t/* detect collision between objects */\\r\\n\\t\\t\\tthis.detectCollisions(validObjects, collisionGrid);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* n^3 which i don't like */\\r\\n\\tdetectLineCollisions(lineObjects, objects) {\\r\\n\\t\\tfor (let i = 0; i < objects.length; i++) {\\r\\n\\t\\t\\tif (objects[i].getComponent(\\\"rigidbody\\\").type === \\\"circle\\\") {\\r\\n\\t\\t\\t\\tlet transform = objects[i].getComponent(\\\"transform\\\");\\r\\n\\t\\t\\t\\tlet rigidbody = objects[i].getComponent(\\\"rigidbody\\\");\\r\\n\\t\\t\\t\\tfor (let j = 0; j < lineObjects.length; j++) {\\r\\n\\t\\t\\t\\t\\tlet line = lineObjects[j].getComponent(\\\"line\\\");\\r\\n\\t\\t\\t\\t\\tlet transformLine = lineObjects[j].getComponent(\\\"transform\\\");\\r\\n\\t\\t\\t\\t\\tfor (let k = 0; k < line.points.length - 1; k++) {\\r\\n\\t\\t\\t\\t\\t\\tlet max = Math.max(transform.scaleX, transform.scaleY) / 2;\\r\\n\\t\\t\\t\\t\\t\\tlet cacheCos = Math.cos(transformLine.rotation);\\r\\n\\t\\t\\t\\t\\t\\tlet cacheSin = Math.sin(transformLine.rotation);\\r\\n\\t\\t\\t\\t\\t\\tlet currentPoint = new Vector(transformLine.x + line.points[k].x * cacheCos - line.points[k].y * cacheSin, transformLine.y + line.points[k].y * cacheCos + line.points[k].x * cacheSin);\\r\\n\\t\\t\\t\\t\\t\\tlet nextPoint = new Vector(transformLine.x + line.points[k + 1].x * cacheCos - line.points[k + 1].y * cacheSin, transformLine.y + line.points[k + 1].y * cacheCos + line.points[k + 1].x * cacheSin);\\r\\n\\t\\t\\t\\t\\t\\tif (this.isLineCircleColliding(currentPoint.x, currentPoint.y, nextPoint.x, nextPoint.y, transform.x, transform.y, max)) {\\r\\n\\t\\t\\t\\t\\t\\t\\tlet distanceToLine = this.distanceLinePoint(currentPoint.x, currentPoint.y, nextPoint.x, nextPoint.y, transform.x, transform.y) - max;\\r\\n\\t\\t\\t\\t\\t\\t\\tlet closestPoint = this.getClosestPoint(currentPoint.x, currentPoint.y, nextPoint.x, nextPoint.y, transform.x, transform.y);\\r\\n\\t\\t\\t\\t\\t\\t\\tlet dir = Utils.direction(transform.x, transform.y, closestPoint.x, closestPoint.y);\\r\\n\\t\\t\\t\\t\\t\\t\\tlet impulse = new VectorFromAngle(dir, distanceToLine);\\r\\n\\t\\t\\t\\t\\t\\t\\trigidbody.velocityX += impulse.x * rigidbody.restitution;\\r\\n\\t\\t\\t\\t\\t\\t\\trigidbody.velocityY += impulse.y * rigidbody.restitution;\\r\\n\\t\\t\\t\\t\\t\\t\\ttransform.x += impulse.x * this.errorCorrectionCoefficient;\\r\\n\\t\\t\\t\\t\\t\\t\\ttransform.y += impulse.y * this.errorCorrectionCoefficient;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\",\"/* the render class handles the rendering of gameobjects */\\r\\nclass Renderer {\\r\\n\\tconstructor(canvasId) {\\r\\n\\t\\tthis.canvas = document.getElementById(canvasId);\\r\\n\\t\\t/*\\r\\n\\t\\t *\\tbecause canvas has 2 types of width and height properties:\\r\\n\\t\\t *\\twidth and height of render regions, width and height of element;\\r\\n\\t\\t *\\tfor simplicity, this is set 1:1 so the pixel ratio is 1:!\\r\\n\\t \\t */\\r\\n\\t\\tlet computedStyle = window.getComputedStyle(this.canvas);\\r\\n\\t\\tthis.canvas.width = parseFloat(computedStyle.getPropertyValue(\\\"width\\\"));\\r\\n\\t\\tthis.canvas.height = parseFloat(computedStyle.getPropertyValue(\\\"height\\\"));\\r\\n\\t\\t/* use 2D canvas API instead of 3D webgl */\\r\\n\\t\\tthis.ctx = this.canvas.getContext(\\\"2d\\\");\\r\\n\\t\\t/* typically 1 pixel = 1 unit, however this can be changed */\\r\\n\\t\\tthis.pixelsPerUnit = 1;\\r\\n\\t\\t/* increases performance by not rendering elements outside of the screen, usually true, increases performance by 50% */\\r\\n\\t\\tthis.doFrustumCulling = true;\\r\\n\\t\\t/* profiling */\\r\\n\\t\\tthis.totalGivenElements = 0;\\r\\n\\t\\tthis.totalRenderedElements = 0;\\r\\n\\t\\t/* debugging */\\r\\n\\t\\tthis.drawBoundingBoxes = false;\\r\\n\\t\\tthis.drawGrid = false;\\r\\n\\t\\tthis.gridSize = 50;\\r\\n\\t\\tthis.boundingBoxAroundIndex = null;\\r\\n\\t}\\r\\n\\t/* from a given width, height and angle, generates an axis aligned bounding box that guarantees to be perfectly bound a rectangle*/\\r\\n\\tcalculateRectangleAxisAlignedBoundingBox(width, height, angle) {\\r\\n\\t\\tlet newPoints = [];\\r\\n\\t\\t/* array of untransformed points*/\\r\\n\\t\\tlet points = [\\r\\n\\t\\t\\tnew Vector(-0.5, -0.5),\\r\\n\\t\\t\\tnew Vector(-0.5, 0.5),\\r\\n\\t\\t\\tnew Vector(0.5, -0.5),\\r\\n\\t\\t\\tnew Vector(0.5, 0.5),\\r\\n\\t\\t];\\r\\n\\t\\t/* loop over points and transform them to be the corners of the rectangle */\\r\\n\\t\\tfor (let i = 0; i < points.length; i++) {\\r\\n\\t\\t\\t/* scale up points */\\r\\n\\t\\t\\tpoints[i].multiply(width, height);\\r\\n\\t\\t\\t/* fancy math */\\r\\n\\t\\t\\tlet transformedX = points[i].x * Math.cos(angle) + points[i].y * Math.sin(angle);\\r\\n\\t\\t\\tlet transformedY = points[i].x * Math.sin(angle) + points[i].y * Math.cos(angle);\\r\\n\\t\\t\\tlet vector = new Vector(transformedX, transformedY);\\r\\n\\t\\t\\tnewPoints.push(vector);\\r\\n\\t\\t}\\r\\n\\t\\t/* determine which points need to be used for the edge's of the aligned bounding box */\\r\\n\\t\\tlet minX = Math.min(newPoints[0].x, newPoints[1].x, newPoints[2].x, newPoints[3].x);\\r\\n\\t\\tlet maxX = Math.max(newPoints[0].x, newPoints[1].x, newPoints[2].x, newPoints[3].x);\\r\\n\\t\\tlet minY = Math.min(newPoints[0].y, newPoints[1].y, newPoints[2].y, newPoints[3].y);\\r\\n\\t\\tlet maxY = Math.max(newPoints[0].y, newPoints[1].y, newPoints[2].y, newPoints[3].y);\\r\\n\\t\\t/* center aligned bounding box */\\r\\n\\t\\treturn new Vector(maxX - minX, maxY - minY);\\r\\n\\t}\\r\\n\\tcalculateOvalAxisAlignedBoundingBox(width, height, angle) {\\r\\n\\t\\t/* very simple math */\\r\\n\\t\\tlet x = Math.sqrt(width ** 2 * Math.cos(angle) ** 2 + height ** 2 * Math.sin(angle) ** 2);\\r\\n\\t\\tlet y = Math.sqrt(width ** 2 * Math.sin(angle) ** 2 + height ** 2 * Math.cos(angle) ** 2);\\r\\n\\t\\treturn new Vector(x, y);\\r\\n\\t}\\r\\n\\tsetRenderProperties(renderDetails) {\\r\\n\\t\\t/* set colours */\\r\\n\\t\\tthis.ctx.fillStyle = renderDetails.fillColour;\\r\\n\\t\\tthis.ctx.strokeStyle = renderDetails.strokeColour;\\r\\n\\t\\tthis.ctx.lineWidth = renderDetails.strokeWidth / this.pixelsPerUnit;\\r\\n\\t\\tthis.ctx.globalAlpha = renderDetails.opacity;\\r\\n\\t}\\r\\n\\tsetTransformProperties(calculatedTransform, transform, camera) {\\r\\n\\t\\tthis.ctx.translate(calculatedTransform.x, calculatedTransform.y);\\r\\n\\t\\tthis.ctx.rotate(transform.rotation + camera.getComponent(\\\"transform\\\").rotation);\\r\\n\\t\\tthis.ctx.scale(this.pixelsPerUnit, this.pixelsPerUnit);\\r\\n\\t}\\r\\n\\t/* \\r\\n\\t *\\tinstead of the canvas doing its transformations, then realising it's out of screen and discarding said calculations\\r\\n\\t *\\twhich are expensive, calculate it beforehand using vectors which saves much performance (8ms 1k render --> 3ms 1k render)\\r\\n\\t */\\r\\n\\tcalculateTransformations(transform, camera) {\\r\\n\\t\\tlet cameraTransform = camera.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet objectTransform = new Vector(this.canvas.width / 2, this.canvas.height / 2);\\r\\n\\t\\t/* ignore camera transform if the object is expected to stay on screen */\\r\\n\\t\\tif (transform.fixedOnScreen === false) {\\r\\n\\t\\t\\tobjectTransform.subtract(cameraTransform.x * this.pixelsPerUnit, cameraTransform.y * this.pixelsPerUnit);\\r\\n\\t\\t\\tobjectTransform.add(camera.followOffsetX * this.pixelsPerUnit, camera.followOffsetY * this.pixelsPerUnit);\\r\\n\\t\\t}\\r\\n\\t\\t/* specific object transforms next */\\r\\n\\t\\tobjectTransform.add(transform.x * this.pixelsPerUnit, transform.y * this.pixelsPerUnit);\\r\\n\\r\\n\\t\\treturn objectTransform;\\r\\n\\t}\\r\\n\\t/* given a text and the maximum bounding width, split's the text into multiple lines */\\r\\n\\tmultilineTextSplitBySpace(text, maxWidth) {\\r\\n\\t\\t/* first split text by new lines*/\\r\\n\\t\\tlet split = text.split(/[\\\\n]/);\\r\\n\\t\\tlet output = [];\\r\\n\\t\\tlet last = 0;\\r\\n\\t\\tlet i = 0;\\r\\n\\t\\twhile (i < split.length) {\\r\\n\\t\\t\\tif (split[i] === \\\"\\\") {\\r\\n\\t\\t\\t\\toutput.push(split[i]);\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t\\tlast = i;\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tlet width = this.ctx.measureText(split[i]).width;\\r\\n\\t\\t\\tif (width > maxWidth) {\\r\\n\\t\\t\\t\\tlet split2 = split[i].split(\\\" \\\");\\r\\n\\t\\t\\t\\tlet sumTotal = split2[0];\\r\\n\\t\\t\\t\\tlet jLoops = 0;\\r\\n\\t\\t\\t\\tlet MAX_J_LOOPS = 1000;\\r\\n\\t\\t\\t\\tfor (let j = 1; j < split2.length; j++) {\\r\\n\\t\\t\\t\\t\\tjLoops++;\\r\\n\\t\\t\\t\\t\\tif (jLoops > MAX_J_LOOPS) {\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif (this.ctx.measureText(sumTotal + \\\" \\\" + split2[j]).width < maxWidth) {\\r\\n\\t\\t\\t\\t\\t\\tsumTotal += \\\" \\\" + split2[j];\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\toutput.push(sumTotal);\\r\\n\\t\\t\\t\\t\\t\\tsumTotal = \\\"\\\";\\r\\n\\t\\t\\t\\t\\t\\tif (this.ctx.measureText(split2[j]).width < maxWidth) {\\r\\n\\t\\t\\t\\t\\t\\t\\tj--;\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\toutput.push(sumTotal);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\toutput.push(split[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ti++;\\r\\n\\t\\t}\\r\\n\\t\\treturn output;\\r\\n\\t}\\r\\n\\trenderAxisAlignedBoundingBox(transform, renderDetails, camera) {\\r\\n\\t\\t/* calculate theta, which minuses the rotations of the object and the camera */\\r\\n\\t\\tlet theta = -transform.rotation - camera.getComponent(\\\"transform\\\").rotation;\\r\\n\\t\\t/* anti rotate the canvas so that all bounding boxes are aligned th the horizontal */\\r\\n\\t\\tthis.ctx.rotate(theta);\\r\\n\\t\\t/* set styles */\\r\\n\\t\\tthis.ctx.strokeStyle = \\\"#e4ecef\\\";\\r\\n\\t\\tthis.ctx.setLineDash([5, 5]);\\r\\n\\t\\tthis.ctx.beginPath();\\r\\n\\t\\t/* calculate bounding box for rectangles and ovals */\\r\\n\\t\\tif (renderDetails.shape === \\\"rectangle\\\") {\\r\\n\\t\\t\\tlet boundingBox = this.calculateRectangleAxisAlignedBoundingBox(transform.scaleX, transform.scaleY, transform.rotation);\\r\\n\\t\\t\\tthis.ctx.rect(-boundingBox.x / 2, -boundingBox.y / 2, boundingBox.x, boundingBox.y);\\r\\n\\t\\t} else if (renderDetails.shape === \\\"circle\\\" || renderDetails.type === \\\"text\\\") {\\r\\n\\t\\t\\tlet boundingBox = this.calculateOvalAxisAlignedBoundingBox(transform.scaleX, transform.scaleY, transform.rotation);\\r\\n\\t\\t\\tthis.ctx.rect(-boundingBox.x / 2, -boundingBox.y / 2, boundingBox.x, boundingBox.y);\\r\\n\\t\\t} else if (renderDetails.type === \\\"line\\\") {\\r\\n\\r\\n\\t\\t}\\r\\n\\t\\tthis.ctx.stroke();\\r\\n\\t\\t/* reset line dash */\\r\\n\\t\\tthis.ctx.setLineDash([]);\\r\\n\\t}\\r\\n\\t/* rendering the grid is useful for debugging, it gives users a sense of the size of objects*/\\r\\n\\trenderGrid(camera) {\\r\\n\\t\\tlet gridSize = this.gridSize * this.pixelsPerUnit;\\r\\n\\t\\tlet cameraTransform = camera.getComponent(\\\"transform\\\");\\r\\n\\t\\tlet transformX = -cameraTransform.x * this.pixelsPerUnit;\\r\\n\\t\\tlet transformY = -cameraTransform.y * this.pixelsPerUnit;\\r\\n\\t\\tthis.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);\\r\\n\\t\\t/* auxillary lines */\\r\\n\\t\\tlet negHeight = Math.ceil(this.canvas.height / gridSize);\\r\\n\\t\\tlet negWidth = Math.ceil(this.canvas.width / gridSize);\\r\\n\\t\\tthis.ctx.strokeStyle = \\\"#777777\\\";\\r\\n\\t\\tthis.ctx.lineWidth = 1;\\r\\n\\t\\tthis.ctx.beginPath();\\r\\n\\t\\tfor (let i = -negWidth - 1; i <= negWidth; i++) {\\r\\n\\t\\t\\tthis.ctx.moveTo(i * gridSize + transformX % gridSize, -this.canvas.height / 2);\\r\\n\\t\\t\\tthis.ctx.lineTo(i * gridSize + transformX % gridSize, this.canvas.height / 2);\\r\\n\\t\\t}\\r\\n\\t\\tfor (let i = -negHeight - 1; i <= negHeight; i++) {\\r\\n\\t\\t\\tthis.ctx.moveTo(this.canvas.width / 2, i * gridSize + transformY % gridSize);\\r\\n\\t\\t\\tthis.ctx.lineTo(-this.canvas.width / 2, i * gridSize + transformY % gridSize);\\r\\n\\t\\t}\\r\\n\\t\\tthis.ctx.stroke();\\r\\n\\t\\t/* wide center lines from to denote 0, 0 */\\r\\n\\t\\tthis.ctx.strokeStyle = \\\"#999\\\";\\r\\n\\t\\tthis.ctx.lineWidth = 3;\\r\\n\\t\\tthis.ctx.beginPath();\\r\\n\\t\\tthis.ctx.moveTo(-this.canvas.width / 2, transformY);\\r\\n\\t\\tthis.ctx.lineTo(this.canvas.width / 2, transformY);\\r\\n\\t\\tthis.ctx.moveTo(transformX, -this.canvas.height / 2);\\r\\n\\t\\tthis.ctx.lineTo(transformX, this.canvas.height / 2);\\r\\n\\t\\tthis.ctx.stroke();\\r\\n\\t}\\r\\n\\trenderShape(transform, renderDetails) {\\r\\n\\t\\t/*\\t\\r\\n\\t\\t *\\tsince the base unit one pixel and everything is rendered based on the radius, the values \\r\\n\\t\\t *\\tfor rendering size is 0.5\\r\\n\\t\\t */\\r\\n\\t\\tif (renderDetails.shape === \\\"circle\\\") {\\r\\n\\t\\t\\t/* ellipse has a built in rotation function, so no rotations must be done */\\r\\n\\t\\t\\t/* ellipses render from the center, so no offset required */\\r\\n\\t\\t\\tthis.ctx.ellipse(0, 0, 0.5 * transform.scaleX, 0.5 * transform.scaleY, 0, 0, 2 * Math.PI);\\r\\n\\t\\t} else if (renderDetails.shape === \\\"rectangle\\\") {\\r\\n\\t\\t\\t/* since rectangle draw from the upper left, the transform must be subtracted so it is based off the center */\\r\\n\\t\\t\\tthis.ctx.rect(-0.5 * transform.scaleX, -0.5 * transform.scaleY, transform.scaleX, transform.scaleY);\\r\\n\\t\\t}\\r\\n\\t\\tthis.ctx.fill();\\r\\n\\t\\tthis.ctx.stroke();\\r\\n\\t}\\r\\n\\trenderLine(transform, renderDetails, lineData) {\\r\\n\\t\\tif (lineData) {\\r\\n\\t\\t\\tthis.ctx.beginPath();\\r\\n\\t\\t\\tthis.ctx.strokeStyle = renderDetails.strokeColour;\\r\\n\\t\\t\\tthis.ctx.lineWidth = renderDetails.strokeWidth;\\r\\n\\t\\t\\tthis.ctx.lineCap = renderDetails.lineCap;\\r\\n\\t\\t\\tthis.ctx.lineJoin = renderDetails.lineJoin;\\r\\n\\t\\t\\tfor (let i = 0; i < lineData.points.length; i++) {\\r\\n\\t\\t\\t\\tthis.ctx.lineTo(lineData.points[i].x, lineData.points[i].y);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (lineData.connectEnds === true && lineData.points.length > 2) {\\r\\n\\t\\t\\t\\tthis.ctx.lineTo(lineData.points[0].x, lineData.points[0].y)\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.ctx.stroke();\\r\\n\\t\\t\\tif (renderDetails.fill) {\\r\\n\\t\\t\\t\\tthis.ctx.fill();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\trenderTexture(transform, renderDetails) {\\r\\n\\t\\t/* since images render from upper left, transform must be subtracted so it is based off the center */\\r\\n\\t\\tthis.ctx.drawImage(renderDetails.texture, -0.5 * transform.scaleX * renderDetails.textureScaleX, -0.5 * transform.scaleY * renderDetails.textureScaleY, transform.scaleX * renderDetails.textureScaleX, transform.scaleY * renderDetails.textureScaleY);\\r\\n\\t}\\r\\n\\trenderText(transform, renderDetails, camera) {\\r\\n\\t\\t/* stringify first */\\r\\n\\t\\tlet text = renderDetails.text.toString();\\r\\n\\t\\t/* generate the text's font */\\r\\n\\t\\tthis.ctx.font = `${renderDetails.style} ${renderDetails.variant} ${renderDetails.weight} ${renderDetails.size}px ${renderDetails.font}`;\\r\\n\\t\\t/* gather metrics about the text */\\r\\n\\t\\tlet metrics = this.ctx.measureText(text);\\r\\n\\t\\t/* since text in canvas renders from the bottom left, calulcating the font height is required so the center of the text is used */\\r\\n\\t\\tlet fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;\\r\\n\\t\\t/* set alignment */\\r\\n\\t\\tthis.ctx.textAlign = renderDetails.alignment;\\r\\n\\r\\n\\t\\tlet offset = 0;\\r\\n\\t\\tif (renderDetails.alignment === \\\"left\\\") {\\r\\n\\t\\t\\toffset = -transform.scaleX / 2;\\r\\n\\t\\t} else if (renderDetails.alignment === \\\"right\\\") {\\r\\n\\t\\t\\toffset = transform.scaleX / 2;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tlet multilineText = this.multilineTextSplitBySpace(text, transform.scaleX);\\r\\n\\t\\tfor (let i = 0; i < multilineText.length; i++) {\\r\\n\\t\\t\\tlet calculatedTransform = this.calculateTransformations(transform, camera);\\r\\n\\t\\t\\tthis.ctx.fillText(multilineText[i], offset, -transform.scaleY / 2 + fontHeight + fontHeight * i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\trenderObject(object, camera, index) {\\r\\n\\t\\t/* get render specific components */\\r\\n\\t\\t\\tlet transform = object.getComponent(\\\"transform\\\");\\r\\n\\t\\t\\tlet renderDetails = object.getComponent(\\\"renderer\\\");\\r\\n\\t\\t\\tif (renderDetails === null || transform === null) {\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tlet componentType = renderDetails.type;\\r\\n\\t\\t\\t/* get bounds for frustom culling */\\r\\n\\t\\t\\tlet maxObjectBounds = Math.max(transform.scaleX, transform.scaleY) / 2 * this.pixelsPerUnit;\\r\\n\\t\\t\\t/* calculate if the given object will be in frame and determine if it should be rendered */\\r\\n\\t\\t\\tlet calculatedTransform = this.calculateTransformations(transform, camera);\\r\\n\\t\\t\\tlet isInFrame = calculatedTransform.x > -maxObjectBounds && calculatedTransform.x < this.canvas.width + maxObjectBounds && calculatedTransform.y > -maxObjectBounds && calculatedTransform.y < this.canvas.height + maxObjectBounds;\\r\\n\\t\\t\\t/* don't frustum cull lines */\\r\\n\\t\\t\\tif ((isInFrame && this.doFrustumCulling) || componentType === \\\"line\\\" || componentType === \\\"text\\\" || this.doFrustumCulling === false) {\\r\\n\\t\\t\\t\\tthis.setTransformProperties(calculatedTransform, transform, camera);\\r\\n\\t\\t\\t\\tthis.ctx.beginPath();\\r\\n\\t\\t\\t\\tthis.setRenderProperties(renderDetails);\\r\\n\\t\\t\\t\\t/*\\tchooses between rendering shapes and images \\r\\n\\t\\t\\t\\t *\\tif a texture is defined it will render images\\r\\n\\t\\t\\t\\t *\\totherwise a shape\\r\\n\\t\\t\\t\\t *\\tshapes are a fallback in case an image cannot be rendered\\r\\n\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\t/* specific component renderers */\\r\\n\\t\\t\\t\\tif (componentType === \\\"mesh\\\") {\\r\\n\\t\\t\\t\\t\\tif (renderDetails.texture === null) { \\r\\n\\t\\t\\t\\t\\t\\t/* draw specific shapes */\\r\\n\\t\\t\\t\\t\\t\\tthis.renderShape(transform, renderDetails);\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t/* drawing iamges */\\r\\n\\t\\t\\t\\t\\t\\tthis.renderTexture(transform, renderDetails);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t} else if (componentType === \\\"text\\\") {\\r\\n\\t\\t\\t\\t\\tthis.renderText(transform, renderDetails, camera);\\r\\n\\t\\t\\t\\t} else if (componentType === \\\"line\\\") {\\r\\n\\t\\t\\t\\t\\tthis.renderLine(transform, renderDetails, object.getComponent(\\\"line\\\"));\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (this.drawBoundingBoxes || this.boundingBoxAroundIndex === index) {\\r\\n\\t\\t\\t\\t\\tthis.renderAxisAlignedBoundingBox(transform, renderDetails, camera);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tthis.totalRenderedElements++;\\r\\n\\t\\t\\t\\t/* reset transformations in preparation of new object */\\r\\n\\t\\t\\t\\tthis.ctx.resetTransform();\\r\\n\\t\\t\\t}\\r\\n\\t}\\r\\n\\trender(scene, camera) {\\r\\n\\t\\tif (this.pixelsPerUnit <= 0) {\\r\\n\\t\\t\\tthis.pixelsPerUnit = 1;\\r\\n\\t\\t}\\r\\n\\t\\tif (camera === undefined || camera.hasComponent(\\\"transform\\\") === false) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tthis.totalRenderedElements = 0;\\r\\n\\t\\tthis.totalGivenElements = scene.objects.length;\\r\\n\\t\\tthis.ctx.globalAlpha = 1;\\r\\n\\t\\t/* get background colour and fill the background */\\r\\n\\t\\tif (scene.background.texture !== null) {\\r\\n\\t\\t\\tthis.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\\r\\n\\t\\t\\tthis.ctx.translate(-scene.background.offsetX + this.canvas.width / 2 + camera.getComponent(\\\"transform\\\").x, -scene.background.offsetY + this.canvas.height / 2 + camera.getComponent(\\\"transform\\\").y);\\r\\n\\t\\t\\tthis.ctx.drawImage(scene.background.texture, -scene.background.texture.width * scene.background.textureScaleX / 2, -scene.background.texture.height * scene.background.textureScaleY / 2, scene.background.texture.width * scene.background.textureScaleX, scene.background.texture.height * scene.background.textureScaleY);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.ctx.fillStyle = scene.background.colour;\\r\\n\\t\\t\\tthis.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\\r\\n\\t\\t}\\r\\n\\t\\tthis.ctx.resetTransform();\\r\\n\\t\\tif (this.drawGrid) {\\r\\n\\t\\t\\tthis.renderGrid(camera);\\r\\n\\t\\t\\tthis.ctx.resetTransform();\\r\\n\\t\\t}\\r\\n\\t\\t/* loop through and render all objects */\\r\\n\\t\\tfor (let i = 0; i < scene.objects.length; i++) {\\r\\n\\t\\t\\tthis.renderObject(scene.objects[i], camera, i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\",\"/* a scene can be considered as a stage */\\r\\nclass Scene {\\r\\n\\tconstructor(id) {\\r\\n\\t\\t/* unique identifier for getting and finding */\\r\\n\\t\\tthis.id = id;\\r\\n\\t\\tthis.objects = [];\\r\\n\\t\\t/* create managers */\\r\\n\\t\\tthis.cameraManager = new CameraManager(this);\\r\\n\\t\\tthis.behaviourManager = new BehaviourManager();\\r\\n\\t\\tthis.background = new Components.BackgroundRenderer();\\r\\n\\r\\n\\t\\tthis.initialised = false;\\r\\n\\t}\\r\\n\\t/* adds external components such as converting behaviour strings to behaviours */\\r\\n\\taddExternalComponents(gameObject) {\\r\\n\\t\\tif (gameObject.hasComponent(\\\"behaviour-script\\\")) {\\r\\n\\t\\t\\tlet behaviour = gameObject.getComponent(\\\"behaviour-script\\\").parse(gameObject);\\r\\n\\t\\t\\tgameObject.addComponent(behaviour);\\r\\n\\t\\t\\tthis.behaviourManager.addBehaviour(behaviour);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* removes external behaviours when they need to be destroyed */\\r\\n\\tremoveExternalComponents(gameObject) {\\r\\n\\t\\tif (gameObject.hasComponent(\\\"behaviour-script\\\")) {\\r\\n\\t\\t\\tthis.behaviourManager.removeBehaviour(gameObject);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* adds a gameObject to the scene */\\r\\n\\taddGameObject(gameObject) {\\r\\n\\t\\tgameObject.attachedScene = this;\\r\\n\\t\\tthis.addExternalComponents(gameObject);\\r\\n\\t\\tthis.objects.push(gameObject);\\r\\n\\t}\\r\\n\\t/* removes a gameObject from the scene*/\\r\\n\\tremoveGameObject(gameObject) {\\r\\n\\t\\tgameObject.attachedScene = null;\\r\\n\\t\\t/* remove attached behaviours */\\r\\n\\t\\tthis.removeExternalComponents(gameObject);\\r\\n\\t\\t/* find the gameObject and splice it */\\r\\n\\t\\tfor (let i = 0; i < this.objects.length; i++) {\\r\\n\\t\\t\\tif (this.objects[i] === gameObject) {\\r\\n\\t\\t\\t\\tthis.objects.splice(i, 1);\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tgetGameObjectById(id) {\\r\\n\\t\\tlet i = 0;\\r\\n\\t\\t/* linear search through all the game objects */\\r\\n\\t\\twhile (i < this.objects.length) {\\r\\n\\t\\t\\tif (this.objects[i].id === id) {\\r\\n\\t\\t\\t\\treturn this.objects[i];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ti++;\\r\\n\\t\\t}\\r\\n\\t\\t/* no element was found, return null */\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\tgetGameObjectIndex(id) {\\r\\n\\t\\tlet i = 0;\\r\\n\\t\\t/* linear search through all the game objects */\\r\\n\\t\\twhile (i < this.objects.length) {\\r\\n\\t\\t\\tif (this.objects[i].id === id) {\\r\\n\\t\\t\\t\\treturn i;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ti++;\\r\\n\\t\\t}\\r\\n\\t\\t/* no element was found, return null */\\r\\n\\t\\treturn null;\\t\\r\\n\\t}\\r\\n\\tinit() {\\r\\n\\t\\tthis.initialised = true;\\r\\n\\t\\t/* load all behaviours */\\r\\n\\t\\tfor (let i = 0; i < this.objects.length; i++) {\\r\\n\\t\\t\\tthis.addExternalComponents(this.objects[i]);\\r\\n\\t\\t}\\r\\n\\t\\t/* initialise all behaviours */\\r\\n\\t\\tthis.behaviourManager.broadcastEvent(\\\"init\\\");\\r\\n\\t}\\r\\n\\tupdate() {\\r\\n\\t\\t/* sort the objects by zIndex ascending to allow objects to be on top or below */\\r\\n\\t\\tthis.objects.sort(function(a, b) {\\r\\n\\t\\t\\tlet aRenderDetails = a.getComponent(\\\"renderer\\\");\\r\\n\\t\\t\\tlet bRenderDetails = b.getComponent(\\\"renderer\\\");\\r\\n\\t\\t\\tif (aRenderDetails && bRenderDetails) {\\r\\n\\t\\t\\t\\treturn aRenderDetails.zIndex - bRenderDetails.zIndex;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* objects without renderer's are last */\\r\\n\\t\\t\\treturn -Infinity;\\r\\n\\t\\t});\\r\\n\\t\\t/* run early update events */\\r\\n\\t\\tthis.behaviourManager.broadcastEvent(\\\"update\\\");\\r\\n\\t\\tthis.cameraManager.update();\\r\\n\\t}\\r\\n\\tlateUpdate() {\\r\\n\\t\\t/* run late update events */\\r\\n\\t\\tthis.behaviourManager.broadcastEvent(\\\"late-update\\\");\\r\\n\\t}\\r\\n}\",\"class SceneManager {\\r\\n\\tconstructor() {\\r\\n\\t\\t/* a hashmap containing all scenes */\\r\\n\\t\\tthis.scenes = {};\\r\\n\\t\\t/* the identifier for the active scene, not a reference to the active scene itself */\\r\\n\\t\\tthis.activeScene = null;\\r\\n\\t}\\r\\n\\tswitchToScene(id) {\\r\\n\\t\\t/* ensure the scene actually exists before switching */\\r\\n\\t\\tif (this.scenes[id]) {\\r\\n\\t\\t\\tthis.activeScene = id;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tconsole.error(`scene with the ID \\\"${id}\\\" does not exist`);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tswitchToSceneAndInit(id) {\\r\\n\\t\\t/* ensure the scene actually exists before switching */\\r\\n\\t\\tif (this.scenes[id]) {\\r\\n\\t\\t\\tthis.activeScene = id;\\r\\n\\t\\t\\tthis.scenes[id].init();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthrow new Error(`UserError: scene with the ID \\\"${id}\\\" does not exist`);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tinitialiseActiveScene() {\\r\\n\\t\\tif (this.activeScene) {\\r\\n\\t\\t\\tthis.scenes[this.activeScene].init();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tconsole.warn(\\\"no active scene to init\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\taddScene(scene) {\\r\\n\\t\\t/* warn about scene overwrites, it is not critical but it can cause unintended behaviour */\\r\\n\\t\\tif (this.scenes[scene.id]) {\\r\\n\\t\\t\\tconsole.warn(`scene with the ID \\\"${scene.id}\\\" already exists, it will be overwritten`);\\r\\n\\t\\t}\\r\\n\\t\\tthis.scenes[scene.id] = scene;\\r\\n\\t}\\r\\n\\tgetScene(id) {\\r\\n\\t\\tif (this.scenes[id]) {\\r\\n\\t\\t\\treturn this.scenes[id];\\r\\n\\t\\t}\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\t/* returns the active scene */\\r\\n\\tgetActiveScene() {\\r\\n\\t\\treturn this.scenes[this.activeScene];\\r\\n\\t}\\r\\n\\t/* renames a scene (used in the gui) */\\r\\n\\trenameScene(currentId, newId) {\\r\\n\\t\\tthis.scenes[currentId].id = newId;\\r\\n\\t\\tthis.scenes[newId] = this.scenes[currentId];\\r\\n\\t\\tdelete this.scenes[currentId];\\r\\n\\t}\\r\\n}\",\"const Utils = (function() {\\r\\n\\tlet self = {\\r\\n\\t\\t/* take a given value, and a given range and maps the value between given range, can also be used as linear interpolation and extrapolation */\\r\\n\\t\\tmap: function(num, numMin, numMax, mapMin, mapMax) {\\r\\n\\t\\t\\treturn mapMin + ((mapMax - mapMin) / (numMax - numMin)) * (num - numMin);\\r\\n\\t\\t},\\r\\n\\t\\t/* gives the direction something faces given 2 points */\\r\\n\\t\\tdirection: function(originX, originY, pointingX, pointingY) {\\r\\n\\t\\t\\treturn Math.atan2(pointingY - originY, pointingX - originX);\\r\\n\\t\\t},\\r\\n\\t\\t/* gives the true euler distance between 2 points */\\r\\n\\t\\tdist: function(x1, y1, x2, y2) {\\r\\n\\t\\t\\treturn Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\\r\\n\\t\\t},\\r\\n\\t\\t/* gives the distance without using square root for perfomance */\\r\\n\\t\\tfastDist: function(x1, y1, x2, y2) {\\r\\n\\t\\t\\treturn Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);\\r\\n\\t\\t},\\r\\n\\t\\t/* as the name says, returns a random floating point number between a given range*/\\r\\n\\t\\trandomRange: function(min, max) {\\r\\n\\t\\t\\treturn min + Math.random() * (max - min);\\r\\n\\t\\t},\\r\\n\\t\\t/* pads a string with a given character up to a given length, prepend true means the padding will be added before the original string*/\\r\\n\\t\\tpad: function(string, length, paddingCharacter, prepend) {\\r\\n\\t\\t\\t/* convert to string first as the length property is needed */\\r\\n\\t\\t\\tstring = string.toString();\\r\\n\\t\\t\\tpaddingCharacter = paddingCharacter.toString();\\r\\n\\t\\t\\tlet paddingString = \\\"\\\";\\r\\n\\t\\t\\tlet paddingLength = length - string.length;\\r\\n\\t\\t\\tfor (let i = 0; i < paddingLength; i++) {\\r\\n\\t\\t\\t\\tpaddingString += paddingCharacter;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (prepend) {\\r\\n\\t\\t\\t\\treturn paddingString + string;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn string + paddingString;\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\t/*\\t\\r\\n\\t\\t *\\tgiven a number, min and max, returns the number if it is within the range\\r\\n\\t\\t *\\treturns the number, if above the max, returns max, and below min returns min\\r\\n\\t\\t */\\r\\n\\t\\tclampRange: function(number, min, max) {\\r\\n\\t\\t\\tlet newNumber = Math.max(number, min);\\r\\n\\t\\t\\tnewNumber = Math.min(newNumber, max);\\r\\n\\t\\t\\treturn newNumber;\\r\\n\\t\\t},\\r\\n\\t\\t/* converts camelCase names to dash names for use in the HTML dom */\\r\\n\\t\\tcamelCaseToDash: function(string) {\\r\\n\\t\\t\\treturn string.replace(/(^[A-Z])/, ([first]) => first.toLowerCase()).replace(/([A-Z])/g, ([letter]) => `-${letter.toLowerCase()}`)\\r\\n\\t\\t},\\r\\n\\t\\t/* converts dash strings from the dom to camel case for variable names */\\r\\n\\t\\tdashToCamelCase: function(string) {\\r\\n\\t\\t\\tlet split = string.split(\\\"-\\\");\\r\\n\\t\\t\\tlet output = split[0];\\r\\n\\t\\t\\tfor (let i = 1; i < split.length; i++) {\\r\\n\\t\\t\\t\\toutput += self.capitaliseFirstLetter(split[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn output;\\r\\n\\t\\t},\\r\\n\\t\\t/* internal captitalisation method */\\r\\n\\t\\tcapitaliseFirstLetter: function(string) {\\r\\n\\t\\t\\treturn string[0].toUpperCase() + string.slice(1);\\r\\n\\t\\t},\\r\\n\\t\\t/* rounds a numebr to a specified decimal place, negative numbers give the effect of integer place value rounding (sig figs) */\\r\\n\\t\\troundDecimals: function(number, decimals) {\\r\\n\\t\\t\\tif (decimals === undefined) {\\r\\n\\t\\t\\t\\tdecimals = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (decimals > 16) {\\r\\n\\t\\t\\t\\tdecimals = 16;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\\r\\n\\t\\t},\\r\\n\\t\\trandomString: function(length) {\\r\\n\\t\\t\\treturn self.randomStringFromLetters(length, \\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\\\");\\r\\n\\t\\t},\\r\\n\\t\\trandomAlphaNumericString: function(length) {\\r\\n\\t\\t\\treturn self.randomStringFromLetters(length, \\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\\");\\r\\n\\t\\t\\r\\n\\t\\t},\\r\\n\\t\\trandomStringFromLetters(length, letters) {\\r\\n\\t\\t\\tlet output = \\\"\\\";\\r\\n\\t\\t\\tlet cacheLength = letters.length - 1;\\r\\n\\t\\t\\tfor (let i = 0; i < length; i++) {\\r\\n\\t\\t\\t\\toutput += letters[Math.round(self.randomRange(0, cacheLength))];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn output;\\r\\n\\t\\t},\\r\\n\\t};\\r\\n\\treturn self;\\r\\n})();\",\"/* x, y vectors are used alot in this project, therefore it makes sense to make a vector class */\\r\\nclass Vector {\\r\\n\\tconstructor(x = 0, y = 0) {\\r\\n\\t\\tthis.x = x;\\r\\n\\t\\tthis.y = y;\\r\\n\\t}\\r\\n\\t/* clones the vector and creates a new instance */\\r\\n\\tclone() {\\r\\n\\t\\treturn new this.constructor(this.x, this.y);\\r\\n\\t}\\r\\n\\t/* simple vector methods */\\r\\n\\tadd(x, y) {\\r\\n\\t\\tthis.x += x;\\r\\n\\t\\tthis.y += y;\\r\\n\\t}\\r\\n\\tsubtract(x, y) {\\r\\n\\t\\tthis.x -= x;\\r\\n\\t\\tthis.y -= y;\\r\\n\\t}\\r\\n\\tmultiply(x, y) {\\r\\n\\t\\tthis.x *= x;\\r\\n\\t\\tthis.y *= y;\\r\\n\\t}\\r\\n\\tdivide(x, y) {\\r\\n\\t\\tthis.x /= x;\\r\\n\\t\\tthis.y /= y;\\r\\n\\t}\\r\\n\\t/* rotates a vector by given radians (clockwise) around the centre point */\\r\\n\\trotate(radians) {\\r\\n\\t\\tlet x1 = this.x;\\r\\n\\t\\tlet y1 = this.y;\\r\\n\\t\\tthis.x = Math.cos(radians) * x1 - Math.sin(radians) * y1;\\r\\n\\t\\tthis.y = Math.sin(radians) * x1 + Math.cos(radians) * y1;\\r\\n\\t}\\r\\n\\t/* gets the angle of the vector relative to the east cardinal direction */\\r\\n\\tangle() {\\r\\n\\t\\treturn Math.atan2(this.x, this.y);\\r\\n\\t}\\r\\n\\t/* gets the euclidean length of a vector */\\r\\n\\tlen() {\\r\\n\\t\\treturn Math.sqrt(this.x ** 2 + this.y ** 2);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n/* simple vector extension that allows for specifing a require length and angle */\\r\\nclass VectorFromAngle extends Vector {\\r\\n\\tconstructor(angle, length) {\\r\\n\\t\\tsuper(Math.cos(angle) * length, Math.sin(angle) * length);\\r\\n\\t}\\r\\n}\",\"/* file manager used to interface between the users files and the program, is also usable with a virtual file system */\\r\\nconst FileManager = (function() {\\r\\n\\t/* internal, private variables specifying if the manager should read from a virtual file system */\\r\\n\\tlet useVirtualFileSystem = false;\\r\\n\\tlet virtualFileSystem = null;\\r\\n\\treturn {\\r\\n\\t\\t/* set's the manager into a state where it should read from the virtual file system */\\r\\n\\t\\tuseVirtualFileSystem: function(vfs) {\\r\\n\\t\\t\\tvirtualFileSystem = vfs;\\r\\n\\t\\t\\tuseVirtualFileSystem = true;\\r\\n\\t\\t},\\r\\n\\t\\tgetType: function(type, path) {\\r\\n\\t\\t\\tlet node = new type();\\r\\n\\t\\t\\t/* if using a virtual file system, then get the files from the system */\\r\\n\\t\\t\\tif (useVirtualFileSystem) {\\r\\n\\t\\t\\t\\tlet fileData = virtualFileSystem.get(path);\\r\\n\\t\\t\\t\\t/* check if the file exists */\\r\\n\\t\\t\\t\\tif (fileData) {\\r\\n\\t\\t\\t\\t\\t/* use data uri*/\\r\\n\\t\\t\\t\\t\\tnode.src = `data:${fileData.type};base64,${fileData.data}`;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthrow new Error(`GET ${path} 404 (Not Found)`);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tnode.src = path;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn node;\\r\\n\\t\\t},\\r\\n\\t\\tgetImage: function(path) {\\r\\n\\t\\t\\treturn this.getType(Image, path);\\r\\n\\t\\t},\\r\\n\\t\\tgetAudio: function(path) {\\r\\n\\t\\t\\treturn this.getType(Audio, path);\\r\\n\\t\\t},\\r\\n\\t};\\r\\n})();\"]");